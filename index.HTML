<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Epic AI Battle (EAIB)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: '#5D5CDE',
                        secondary: '#4a4a8c',
                        accent: '#8C4A8C',
                        golden: {
                            100: '#FFF7E1',
                            200: '#FFE8B3',
                            300: '#FFD97F',
                            400: '#FFC857',
                            500: '#FFB72B',
                            600: '#F99500',
                            700: '#E67700',
                            800: '#B35A00',
                            900: '#8C4500'
                        },
                        light: {
                            bg: '#FFFFFF',
                            text: '#333333',
                            card: '#F7F7F7',
                            border: '#E5E5E5'
                        },
                        dark: {
                            bg: '#181818',
                            text: '#E5E5E5',
                            card: '#262626',
                            border: '#404040'
                        }
                    },
                    animation: {
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'floating': 'floating 3s ease-in-out infinite',
                        'shake': 'shake 0.5s cubic-bezier(.36,.07,.19,.97) both',
                        'glow': 'glow 1.5s ease-in-out infinite alternate',
                        'golden-pulse': 'neon-pulse 2s infinite'
                    },
                    keyframes: {
                        floating: {
                            '0%, 100%': { transform: 'translateY(0)' },
                            '50%': { transform: 'translateY(-10px)' }
                        },
                        shake: {
                            '0%, 100%': { transform: 'translateX(0)' },
                            '10%, 30%, 50%, 70%, 90%': { transform: 'translateX(-5px)' },
                            '20%, 40%, 60%, 80%': { transform: 'translateX(5px)' }
                        },
                        glow: {
                            '0%': { boxShadow: '0 0 5px rgba(255, 215, 0, 0.6)' },
                            '100%': { boxShadow: '0 0 20px rgba(255, 215, 0, 0.9), 0 0 30px rgba(255, 183, 0, 0.6)' }
                        }
                    }
                }
            }
        }
    </script>
    <style>
        /* Custom scrollbar */
        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(93, 92, 222, 0.5);
            border-radius: 4px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(93, 92, 222, 0.8);
        }

        /* Golden Neon Effects */
        @keyframes neon-pulse {
            0% { box-shadow: 0 0 5px rgba(255, 215, 0, 0.6), 0 0 10px rgba(255, 183, 0, 0.4); }
            50% { box-shadow: 0 0 15px rgba(255, 215, 0, 0.8), 0 0 20px rgba(255, 183, 0, 0.6); }
            100% { box-shadow: 0 0 5px rgba(255, 215, 0, 0.6), 0 0 10px rgba(255, 183, 0, 0.4); }
        }

        @keyframes golden-text-glow {
            0% { text-shadow: 0 0 3px rgba(255, 215, 0, 0.7), 0 0 5px rgba(255, 215, 0, 0.5); }
            50% { text-shadow: 0 0 10px rgba(255, 215, 0, 0.9), 0 0 15px rgba(255, 215, 0, 0.7), 0 0 20px rgba(255, 215, 0, 0.5); }
            100% { text-shadow: 0 0 3px rgba(255, 215, 0, 0.7), 0 0 5px rgba(255, 215, 0, 0.5); }
        }

        @keyframes golden-border-flow {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .golden-neon-text {
            animation: golden-text-glow 2s ease-in-out infinite;
            color: #FFD700;
            font-weight: bold;
        }

        .golden-neon-border {
            border: 2px solid transparent;
            background: linear-gradient(90deg, #FFD700, #FFA500, #FFB700, #FFDB58, #FFD700);
            background-size: 300% 300%;
            animation: golden-border-flow 3s ease infinite;
            background-clip: text;
            -webkit-background-clip: padding-box;
            position: relative;
        }

        .golden-neon-border::before {
            content: '';
            position: absolute;
            top: -2px; right: -2px; bottom: -2px; left: -2px;
            background: linear-gradient(90deg, #FFD700, #FFA500, #FFB700, #FFDB58, #FFD700);
            background-size: 300% 300%;
            animation: golden-border-flow 3s ease infinite;
            border-radius: inherit;
            z-index: -1;
        }

        .golden-glow {
            animation: neon-pulse 2s infinite;
        }

        .golden-button {
            background: linear-gradient(to right, #FFD700, #FFA500);
            color: #000;
            border: none;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .golden-button::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(to right, transparent, rgba(255, 255, 255, 0.4), transparent);
            transform: translateX(-100%);
            transition: all 0.5s ease;
        }

        .golden-button:hover::after {
            transform: translateX(100%);
        }

        /* 3D Effects */
        .perspective-container {
            perspective: 1000px;
        }

        .rotate-on-hover {
            transition: transform 0.5s ease;
            transform-style: preserve-3d;
        }

        .rotate-on-hover:hover {
            transform: rotateY(10deg) rotateX(5deg);
        }

        .card-3d {
            transform-style: preserve-3d;
            transition: all 0.5s ease;
        }

        .card-3d:hover {
            transform: translateZ(10px);
        }

        .card-3d-content {
            transform: translateZ(20px);
        }

        .parallax-effect {
            transform-style: preserve-3d;
            transform: perspective(1000px);
        }

        .parallax-layer {
            position: relative;
            will-change: transform;
        }

        /* Character card effects */
        .character-card {
            transition: all 0.3s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            transform-style: preserve-3d;
            perspective: 1000px;
        }
        
        .character-card.selected {
            box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.6);
            animation: neon-pulse 2s infinite;
            transform: translateZ(10px);
        }
        
        .dark .character-card.selected {
            box-shadow: 0 0 15px 5px rgba(255, 215, 0, 0.8);
        }
        
        .leader-card {
            position: relative;
            overflow: hidden;
        }
        
        .leader-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #FFD700, #FFA500, #FFD700);
            animation: golden-border-flow 3s linear infinite;
            background-size: 200% 200%;
        }
        
        .theme-golden-hour {
            --color-primary: #F99500;
            --color-secondary: #B35A00;
            --color-accent: #8C4500;
            --card-bg: #FFF7E1;
            --text-color: #8C4500;
            --border-color: #FFD97F;
            
            background: linear-gradient(135deg, #FFF7E1, #FFE8B3, #FFD97F);
            color: var(--text-color);
        }
        
        .theme-golden-hour .bg-primary {
            background-color: var(--color-primary) !important;
        }
        
        .theme-golden-hour .text-primary {
            color: var(--color-primary) !important;
        }
        
        .theme-golden-hour .border-primary {
            border-color: var(--color-primary) !important;
        }

        /* Battle animations with 3D enhancements */
        @keyframes attack-animation {
            0% { transform: translateX(0) translateZ(0); }
            25% { transform: translateX(-15px) translateZ(10px) rotateY(-5deg); }
            50% { transform: translateX(10px) translateZ(5px) rotateY(3deg); }
            100% { transform: translateX(0) translateZ(0); }
        }
        
        @keyframes aerial-attack {
            0% { transform: translateY(0) translateX(0) translateZ(0); }
            25% { transform: translateY(-15px) translateX(-5px) translateZ(15px) rotateX(-10deg); }
            50% { transform: translateY(-10px) translateX(-15px) translateZ(25px) rotateX(-15deg); }
            75% { transform: translateY(-5px) translateX(5px) translateZ(10px) rotateX(-5deg); }
            100% { transform: translateY(0) translateX(0) translateZ(0); }
        }
        
        @keyframes ground-attack {
            0% { transform: translateY(0) translateZ(0) rotateX(0); }
            25% { transform: translateY(5px) translateZ(-5px) rotateX(5deg); }
            50% { transform: translateY(0) translateX(-10px) translateZ(-10px) rotateX(8deg); }
            75% { transform: translateY(3px) translateX(5px) translateZ(-5px) rotateX(3deg); }
            100% { transform: translateY(0) translateZ(0) rotateX(0); }
        }
        
        @keyframes coordinate-attack {
            0% { transform: scale3d(1, 1, 1) translateZ(0); }
            25% { transform: scale3d(1.05, 1.05, 1.05) translateX(-5px) translateZ(10px); }
            50% { transform: scale3d(1.1, 1.1, 1.1) translateX(5px) translateZ(20px); }
            75% { transform: scale3d(1.05, 1.05, 1.05) translateX(-3px) translateZ(10px); }
            100% { transform: scale3d(1, 1, 1) translateZ(0); }
        }
        
        @keyframes hold-ground {
            0% { transform: scale3d(1, 1, 1) translateZ(0); }
            50% { transform: scale3d(1.08, 1.08, 1.08) translateZ(15px); box-shadow: 0 0 15px rgba(255, 215, 0, 0.6), 0 0 30px rgba(255, 183, 0, 0.3); }
            100% { transform: scale3d(1, 1, 1) translateZ(0); }
        }
        
        @keyframes play-by-ear {
            0% { transform: rotate3d(0, 1, 0, 0deg) translateZ(0); }
            25% { transform: rotate3d(0, 1, 0, -3deg) translateX(-3px) translateZ(5px); }
            50% { transform: rotate3d(0, 1, 0, 3deg) translateX(3px) translateZ(10px); }
            75% { transform: rotate3d(0, 1, 0, -1deg) translateX(-2px) translateZ(5px); }
            100% { transform: rotate3d(0, 1, 0, 0deg) translateZ(0); }
        }
        
        @keyframes defend-animation {
            0% { transform: scale3d(1, 1, 1) translateZ(0); }
            50% { transform: scale3d(1.05, 1.05, 1.05) translateZ(20px); box-shadow: 0 0 15px rgba(255, 215, 0, 0.6), 0 0 30px rgba(255, 183, 0, 0.4); }
            100% { transform: scale3d(1, 1, 1) translateZ(0); }
        }
        
        @keyframes damage-animation {
            0% { transform: translateX(0) translateZ(0); filter: brightness(1); }
            25% { transform: translateX(10px) translateZ(-5px) rotateY(-3deg); filter: brightness(1.5); }
            50% { transform: translateX(-5px) translateZ(-10px) rotateY(5deg); filter: brightness(1.2); }
            100% { transform: translateX(0) translateZ(0); filter: brightness(1); }
        }
        
        @keyframes ultimate-animation {
            0% { transform: scale3d(1, 1, 1) translateZ(0) rotate3d(0, 1, 0, 0deg); filter: brightness(1); }
            25% { transform: scale3d(1.1, 1.1, 1.1) translateZ(20px) rotate3d(0, 1, 0, 5deg); filter: brightness(1.5); }
            50% { transform: scale3d(1.2, 1.2, 1.2) translateZ(40px) rotate3d(0, 1, 0, -5deg); filter: brightness(1.8); box-shadow: 0 0 30px rgba(255, 215, 0, 0.9), 0 0 50px rgba(255, 183, 0, 0.6); }
            75% { transform: scale3d(1.1, 1.1, 1.1) translateZ(20px) rotate3d(0, 1, 0, 3deg); filter: brightness(1.5); }
            100% { transform: scale3d(1, 1, 1) translateZ(0) rotate3d(0, 1, 0, 0deg); filter: brightness(1); }
        }
        
        .attack { animation: attack-animation 0.5s ease-in-out; transform-style: preserve-3d; }
        .aerial { animation: aerial-attack 0.7s ease-in-out; transform-style: preserve-3d; }
        .ground { animation: ground-attack 0.6s ease-in-out; transform-style: preserve-3d; }
        .coordinate { animation: coordinate-attack 0.8s ease-in-out; transform-style: preserve-3d; }
        .hold-ground { animation: hold-ground 0.6s ease-in-out; transform-style: preserve-3d; }
        .play-by-ear { animation: play-by-ear 0.7s ease-in-out; transform-style: preserve-3d; }
        .defend { animation: defend-animation 0.5s ease-in-out; transform-style: preserve-3d; }
        .damage { animation: damage-animation 0.5s ease-in-out; transform-style: preserve-3d; }
        .ultimate { animation: ultimate-animation 1s ease-in-out; transform-style: preserve-3d; }

        /* Battle log styling */
        .battle-log p {
            margin-bottom: 0.5rem;
        }
        
        .battle-log em {
            color: #8C4A8C;
            font-style: italic;
        }
        
        .dark .battle-log em {
            color: #b975b9;
        }
        
        .theme-golden-hour .battle-log em {
            color: #B35A00;
        }
        
        .battle-log strong {
            color: #5D5CDE;
            font-weight: bold;
        }
        
        .theme-golden-hour .battle-log strong {
            color: #E67700;
            font-weight: bold;
        }
        
        .battle-log h3 {
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
            font-weight: bold;
            color: #4a4a8c;
        }
        
        .dark .battle-log h3 {
            color: #8C8CFF;
        }
        
        .status-effect {
            display: inline-block;
            margin-left: 5px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            vertical-align: middle;
            box-shadow: 0 0 5px rgba(255, 255, 255, 0.5);
        }
        
        .status-effect.stunned {
            background-color: #FFC857;
            box-shadow: 0 0 5px rgba(255, 200, 87, 0.7);
        }
        
        .status-effect.poisoned {
            background-color: #7CB45B;
            box-shadow: 0 0 5px rgba(124, 180, 91, 0.7);
        }
        
        .status-effect.burned {
            background-color: #E05263;
            box-shadow: 0 0 5px rgba(224, 82, 99, 0.7);
        }
        
        .status-effect.frozen {
            background-color: #73C2FB;
            box-shadow: 0 0 5px rgba(115, 194, 251, 0.7);
        }
        
        .status-effect.strengthened {
            background-color: #5D5CDE;
            box-shadow: 0 0 5px rgba(93, 92, 222, 0.7);
        }
        
        /* Media queries for mobile optimization */
        @media (max-width: 640px) {
            .action-btn {
                padding: 0.5rem;
            }
            
            .character-card {
                padding: 0.5rem;
            }
            
            .battle-controls {
                padding: 0.75rem;
            }
            
            .battle-log {
                height: 180px;
            }
        }
        
        /* Audio player styling */
        .audio-player {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border-radius: 30px;
            padding: 5px 15px;
            display: flex;
            align-items: center;
            color: white;
            z-index: 100;
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
            border: 1px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(5px);
        }
        
        .audio-controls {
            display: flex;
            align-items: center;
        }
        
        .play-pause-btn {
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 10px;
        }
        
        .volume-control {
            width: 80px;
            margin: 0 10px;
        }
        
        .track-info {
            margin-left: 10px;
            font-size: 12px;
            max-width: 150px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        /* Chat bot styles */
        .chatbot-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 350px;
            max-width: calc(100vw - 40px);
            height: 450px;
            max-height: 80vh;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
            border-radius: 12px;
            z-index: 1000;
            transition: all 0.3s ease;
            overflow: hidden;
            backdrop-filter: blur(5px);
        }
        
        .chatbot-header {
            padding: 12px;
            cursor: pointer;
        }
        
        .chatbot-messages {
            height: calc(100% - 110px);
            overflow-y: auto;
            padding: 12px;
        }
        
        .chatbot-input-container {
            height: 60px;
            border-top: 1px solid rgba(0, 0, 0, 0.1);
            padding: 10px;
        }
        
        .message {
            padding: 8px 12px;
            border-radius: 15px;
            margin-bottom: 8px;
            max-width: 85%;
            word-wrap: break-word;
        }
        
        .bot-message {
            background-color: rgba(93, 92, 222, 0.1);
            margin-right: auto;
            border-top-left-radius: 5px;
        }
        
        .user-message {
            background-color: rgba(93, 92, 222, 0.7);
            color: white;
            margin-left: auto;
            border-top-right-radius: 5px;
        }
        
        .minimized {
            height: 50px;
            width: 50px;
            border-radius: 25px;
        }
        
        .minimized .chatbot-messages,
        .minimized .chatbot-input-container {
            display: none;
        }
        
        .aspect-selector label {
            cursor: pointer;
        }
        
        .aspect-selector input:checked + span {
            background-color: rgba(93, 92, 222, 0.1);
            border-color: #5D5CDE;
        }
        
        /* Particle effects */
        .particles-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        
        .particle {
            position: absolute;
            background: radial-gradient(circle, rgba(255,215,0,0.8) 0%, rgba(255,215,0,0) 70%);
            border-radius: 50%;
            opacity: 0;
            animation: float-particle 3s ease-in-out infinite;
        }
        
        @keyframes float-particle {
            0% { transform: translateY(0) translateX(0); opacity: 0; }
            20% { opacity: 0.7; }
            80% { opacity: 0.7; }
            100% { transform: translateY(-100px) translateX(20px); opacity: 0; }
        }
    </style>
</head>
<body class="min-h-screen bg-light-bg dark:bg-dark-bg text-light-text dark:text-dark-text transition-colors duration-300 perspective-container">
    <!-- Golden particles container -->
    <div class="particles-container" id="particles-container"></div>

    <!-- Audio player -->
    <div class="audio-player" id="audio-player">
        <div class="audio-controls">
            <button class="play-pause-btn" id="play-pause-btn">▶</button>
            <div>
                <input type="range" min="0" max="100" value="70" class="volume-control" id="volume-control">
            </div>
        </div>
        <div class="track-info" id="track-info">Battle Theme</div>
    </div>

    <!-- Audio elements -->
    <audio id="battle-theme" loop>
        <source src="https://cdn.jsdelivr.net/gh/jbristow/asset-testers/music/Rolemusic_-_07_-_Beach_Wedding_Dance.mp3" type="audio/mpeg">
    </audio>
    <audio id="attack-sound">
        <source src="https://cdn.jsdelivr.net/gh/jbristow/asset-testers/blipSelect.wav" type="audio/wav">
    </audio>
    <audio id="ultimate-sound">
        <source src="https://cdn.jsdelivr.net/gh/jbristow/asset-testers/powerUp.wav" type="audio/wav">
    </audio>
    <audio id="victory-sound">
        <source src="https://cdn.jsdelivr.net/gh/jbristow/asset-testers/jingles_SAX06.ogg" type="audio/ogg">
    </audio>
    <audio id="defeat-sound">
        <source src="https://cdn.jsdelivr.net/gh/jbristow/asset-testers/jingles_SAX12.ogg" type="audio/ogg">
    </audio>

    <div id="app" class="container max-w-4xl mx-auto px-4 py-4 md:py-6">
        <!-- Game Header -->
        <header class="mb-4 md:mb-6 text-center">
            <h1 class="text-2xl md:text-4xl font-bold golden-neon-text mb-1 md:mb-2">Epic AI Battle</h1>
            <p class="text-xs md:text-base opacity-75">Assemble your team of legendary characters and battle for supremacy!</p>
            
            <!-- Theme selector -->
            <div class="flex justify-center mt-2 space-x-3">
                <button id="theme-default" class="theme-btn px-2 py-1 text-xs rounded-full bg-primary bg-opacity-20 hover:bg-opacity-40 transition-all golden-glow">Default</button>
                <button id="theme-golden-hour" class="theme-btn px-2 py-1 text-xs rounded-full bg-golden-400 bg-opacity-20 hover:bg-opacity-40 transition-all">Golden Hour</button>
            </div>
        </header>

        <!-- Game Screens -->
        <div id="game-screens">
            <!-- Team Selection Screen -->
            <div id="team-selection-screen" class="game-screen">
                <div class="mb-4 md:mb-6">
                    <h2 class="text-xl md:text-2xl font-semibold mb-1 md:mb-2 golden-neon-text">Select Your Team</h2>
                    <p class="text-xs md:text-sm opacity-75">Choose 3 characters to form your ultimate battle team, Choose A team captain and inital strategy and battle in a simulation against the AimI.. Good luck CHAMPION</p>
                </div>
                
                <div class="mb-3 md:mb-4">
                    <label class="block text-sm font-medium mb-1">Universe Filter:</label>
                    <div class="flex flex-wrap gap-2">
                        <button class="universe-filter px-3 py-1 text-xs md:text-sm rounded-full bg-primary bg-opacity-20 hover:bg-opacity-40 transition-all golden-glow" data-universe="all">All</button>
                        <button class="universe-filter px-3 py-1 text-xs md:text-sm rounded-full bg-opacity-10 hover:bg-opacity-40 transition-all" data-universe="marvel">Marvel</button>
                        <button class="universe-filter px-3 py-1 text-xs md:text-sm rounded-full bg-opacity-10 hover:bg-opacity-40 transition-all" data-universe="dc">DC</button>
                        <button class="universe-filter px-3 py-1 text-xs md:text-sm rounded-full bg-opacity-10 hover:bg-opacity-40 transition-all" data-universe="other">Other</button>
                    </div>
                </div>
                
                <!-- Character Selection Grid -->
                <div id="character-selection" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-3 mb-4 md:mb-6 perspective-container">
                    <!-- Character cards will be dynamically inserted here -->
                </div>
                
                <!-- Selected Team -->
                <div class="mb-4">
                    <h3 class="text-lg font-semibold mb-2 golden-neon-text">Your Team</h3>
                    <div id="selected-team" class="flex flex-wrap gap-4 min-h-[100px] p-3 md:p-4 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border golden-neon-border">
                        <p id="empty-team-message" class="w-full text-center opacity-50 my-auto">Select characters to add to your team</p>
                        <!-- Selected character cards will appear here -->
                    </div>
                    
                    <div id="team-synergy" class="mt-2 text-xs md:text-sm">
                        <!-- Synergy information will appear here -->
                    </div>
                </div>
                
                <!-- Team Leader Selection -->
                <div id="leader-selection" class="mb-4 hidden">
                    <h3 class="text-lg font-semibold mb-2 golden-neon-text">Team Leader</h3>
                    <p class="text-xs md:text-sm opacity-75 mb-2">Select a character to lead your team (gain leadership bonuses)</p>
                    <div id="leader-options" class="flex flex-wrap gap-3 perspective-container">
                        <!-- Leader options will appear here -->
                    </div>
                </div>
                
                <!-- Team Strategy Selection -->
                <div id="strategy-selection" class="mb-4 hidden">
                    <h3 class="text-lg font-semibold mb-2 golden-neon-text">Battle Strategy</h3>
                    <p class="text-xs md:text-sm opacity-75 mb-2">Choose your team's approach to battle</p>
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-3 perspective-container">
                        <div class="strategy-option cursor-pointer p-3 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border hover:border-primary transition-all card-3d" data-strategy="offensive">
                            <div class="card-3d-content">
                                <h4 class="font-medium text-sm md:text-base">Offensive</h4>
                                <p class="text-xs opacity-75">Increased damage, reduced defense</p>
                            </div>
                        </div>
                        <div class="strategy-option cursor-pointer p-3 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border hover:border-primary transition-all card-3d" data-strategy="defensive">
                            <div class="card-3d-content">
                                <h4 class="font-medium text-sm md:text-base">Defensive</h4>
                                <p class="text-xs opacity-75">Increased defense, reduced damage</p>
                            </div>
                        </div>
                        <div class="strategy-option cursor-pointer p-3 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border hover:border-primary transition-all card-3d" data-strategy="balanced">
                            <div class="card-3d-content">
                                <h4 class="font-medium text-sm md:text-base">Balanced</h4>
                                <p class="text-xs opacity-75">Equal focus on offense and defense</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Battle Style Selection -->
                <div id="battle-style-selection" class="mb-4 hidden">
                    <h3 class="text-lg font-semibold mb-2 golden-neon-text">Battle Style</h3>
                    <p class="text-xs md:text-sm opacity-75 mb-2">Choose your preferred combat approach</p>
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-2 md:gap-3 perspective-container">
                        <div class="battle-style-option cursor-pointer p-2 md:p-3 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border hover:border-primary transition-all card-3d" data-style="aerial-assault">
                            <div class="card-3d-content">
                                <h4 class="font-medium text-sm">Aerial Assault</h4>
                                <p class="text-xs opacity-75">Attack from above with increased speed</p>
                            </div>
                        </div>
                        <div class="battle-style-option cursor-pointer p-2 md:p-3 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border hover:border-primary transition-all card-3d" data-style="ground-assault">
                            <div class="card-3d-content">
                                <h4 class="font-medium text-sm">Ground Assault</h4>
                                <p class="text-xs opacity-75">Focus on powerful close combat</p>
                            </div>
                        </div>
                        <div class="battle-style-option cursor-pointer p-2 md:p-3 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border hover:border-primary transition-all card-3d" data-style="coordinate-attacks">
                            <div class="card-3d-content">
                                <h4 class="font-medium text-sm">Coordinate Attacks</h4>
                                <p class="text-xs opacity-75">Team-based combo opportunities</p>
                            </div>
                        </div>
                        <div class="battle-style-option cursor-pointer p-2 md:p-3 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border hover:border-primary transition-all card-3d" data-style="hold-your-ground">
                            <div class="card-3d-content">
                                <h4 class="font-medium text-sm">Hold Your Ground</h4>
                                <p class="text-xs opacity-75">Defensive stance with counter-attacks</p>
                            </div>
                        </div>
                        <div class="battle-style-option cursor-pointer p-2 md:p-3 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border hover:border-primary transition-all card-3d" data-style="play-by-ear">
                            <div class="card-3d-content">
                                <h4 class="font-medium text-sm">Play By Ear</h4>
                                <p class="text-xs opacity-75">Adapt to situations dynamically</p>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Aspect Ratio Selection -->
                <div class="mb-4">
                    <h3 class="text-lg font-semibold mb-2 golden-neon-text">Display Settings</h3>
                    <div class="aspect-selector flex flex-wrap gap-3">
                        <label class="cursor-pointer">
                            <input type="radio" name="aspect" value="auto" class="hidden" checked>
                            <span class="block px-3 py-1 text-xs md:text-sm border rounded-full border-light-border dark:border-dark-border hover:border-primary transition-all">Auto</span>
                        </label>
                        <label class="cursor-pointer">
                            <input type="radio" name="aspect" value="square" class="hidden">
                            <span class="block px-3 py-1 text-xs md:text-sm border rounded-full border-light-border dark:border-dark-border hover:border-primary transition-all">1:1</span>
                        </label>
                        <label class="cursor-pointer">
                            <input type="radio" name="aspect" value="classic" class="hidden">
                            <span class="block px-3 py-1 text-xs md:text-sm border rounded-full border-light-border dark:border-dark-border hover:border-primary transition-all">4:3</span>
                        </label>
                        <label class="cursor-pointer">
                            <input type="radio" name="aspect" value="wide" class="hidden">
                            <span class="block px-3 py-1 text-xs md:text-sm border rounded-full border-light-border dark:border-dark-border hover:border-primary transition-all">16:9</span>
                        </label>
                    </div>
                </div>
                
                <div class="flex justify-between">
                    <div>
                        <button id="reset-team" class="px-3 md:px-4 py-2 text-sm md:text-base text-primary border border-primary rounded-md hover:bg-primary hover:bg-opacity-10 transition-colors">Reset Team</button>
                    </div>
                    <div>
                        <button id="battle-history" class="mr-2 px-3 py-2 text-sm md:text-base bg-primary bg-opacity-20 hover:bg-opacity-40 rounded-md transition-colors">Battle History</button>
                        <button id="start-battle" class="golden-button px-4 md:px-6 py-2 text-sm md:text-base rounded-md hover:bg-secondary transition-colors" disabled>Start Battle</button>
                    </div>
                </div>
            </div>

            <!-- Battle Screen -->
            <div id="battle-screen" class="game-screen hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl md:text-2xl font-semibold golden-neon-text">Battle Arena</h2>
                    <div class="flex items-center gap-2">
                        <span id="battle-style-indicator" class="hidden md:inline-block px-3 py-1 bg-primary bg-opacity-20 rounded-full text-xs">Style: Aerial Assault</span>
                        <span id="round-counter" class="px-3 py-1 bg-primary bg-opacity-20 rounded-full text-xs md:text-sm font-medium golden-glow">Round 1</span>
                    </div>
                </div>
                
                <!-- Battle Arena -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 md:mb-6 perspective-container">
                    <!-- Player Team -->
                    <div class="space-y-2 md:space-y-3">
                        <div class="flex justify-between items-center">
                            <h3 class="text-base md:text-lg font-medium golden-neon-text">Your Team</h3>
                            <span id="player-strategy" class="text-xs px-2 py-0.5 bg-primary bg-opacity-10 rounded-full">Balanced</span>
                        </div>
                        <div id="player-team" class="space-y-2">
                            <!-- Player characters will appear here -->
                        </div>
                    </div>
                    
                    <!-- AI Team -->
                    <div class="space-y-2 md:space-y-3">
                        <div class="flex justify-between items-center">
                            <h3 class="text-base md:text-lg font-medium golden-neon-text">Opponent Team</h3>
                            <span id="ai-strategy" class="text-xs px-2 py-0.5 bg-primary bg-opacity-10 rounded-full">Offensive</span>
                        </div>
                        <div id="ai-team" class="space-y-2">
                            <!-- AI characters will appear here -->
                        </div>
                    </div>
                </div>
                
                <!-- Battle Controls -->
                <div id="battle-controls" class="mb-4 md:mb-6 p-3 md:p-4 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border golden-neon-border">
                    <div id="action-selection" class="mb-3 md:mb-4">
                        <h3 class="text-base md:text-lg font-medium mb-1 md:mb-2 golden-neon-text">Choose Your Action</h3>
                        <div id="active-character-info" class="mb-2 md:mb-3 text-xs md:text-sm"></div>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-2 md:gap-3 perspective-container">
                            <button class="action-btn px-3 md:px-4 py-2 text-xs md:text-base bg-primary bg-opacity-20 hover:bg-opacity-40 rounded-md transition-all card-3d" data-action="attack">
                                <span class="font-medium">Attack</span>
                                <span class="block text-xs opacity-75">Deal damage</span>
                            </button>
                            <button class="action-btn px-3 md:px-4 py-2 text-xs md:text-base bg-primary bg-opacity-20 hover:bg-opacity-40 rounded-md transition-all card-3d" data-action="defend">
                                <span class="font-medium">Defend</span>
                                <span class="block text-xs opacity-75">Reduce damage</span>
                            </button>
                            <button class="action-btn ultimate-btn px-3 md:px-4 py-2 text-xs md:text-base bg-primary bg-opacity-20 hover:bg-opacity-40 rounded-md transition-all card-3d" data-action="special">
                                <span class="font-medium">Special</span>
                                <span class="block text-xs opacity-75 special-desc">Unique ability</span>
                            </button>
                            <button class="action-btn px-3 md:px-4 py-2 text-xs md:text-base bg-primary bg-opacity-20 hover:bg-opacity-40 rounded-md transition-all col-span-2 md:col-span-3 card-3d" data-action="skill">
                                <span class="font-medium">Character Skills</span>
                                <span class="block text-xs opacity-75" id="skill-list">Select to view available skills</span>
                            </button>
                        </div>
                    </div>
                    
                    <div id="skill-selection" class="hidden mb-3">
                        <h3 class="text-base md:text-lg font-medium mb-1 md:mb-2 golden-neon-text">Select Skill</h3>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-2 perspective-container" id="skill-buttons">
                            <!-- Skill buttons will be dynamically generated -->
                        </div>
                        <button id="back-to-actions-from-skills" class="mt-2 px-3 py-1 text-xs md:text-sm border border-primary text-primary rounded-md hover:bg-primary hover:bg-opacity-10 transition-colors">Back</button>
                    </div>
                    
                    <div id="target-selection" class="hidden">
                        <h3 class="text-base md:text-lg font-medium mb-1 md:mb-2 golden-neon-text">Select Target</h3>
                        <div class="grid grid-cols-2 md:grid-cols-3 gap-2 md:gap-3 perspective-container" id="target-buttons">
                            <!-- Target buttons will be dynamically generated -->
                        </div>
                        <button id="back-to-actions" class="mt-2 px-3 py-1 text-xs md:text-sm border border-primary text-primary rounded-md hover:bg-primary hover:bg-opacity-10 transition-colors">Back</button>
                    </div>
                </div>
                
                <!-- Battle Log -->
                <div class="mb-4 md:mb-6">
                    <div class="flex justify-between items-center mb-1 md:mb-2">
                        <h3 class="text-base md:text-lg font-medium golden-neon-text">Battle Log</h3>
                        <button id="toggle-error-log" class="text-xs px-2 py-1 border border-primary text-primary rounded-md hover:bg-primary hover:bg-opacity-10 transition-colors">Show Errors</button>
                    </div>
                    <div id="battle-log" class="battle-log h-48 md:h-64 overflow-y-auto custom-scrollbar p-3 md:p-4 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border golden-neon-border">
                        <p class="text-center opacity-50">The battle will begin shortly...</p>
                    </div>
                    <div id="error-log" class="battle-log h-32 overflow-y-auto custom-scrollbar p-3 md:p-4 bg-light-card dark:bg-dark-card rounded-lg border border-red-300 dark:border-red-700 mt-2 hidden">
                        <p class="text-center opacity-50">Error log will appear here...</p>
                    </div>
                </div>
                
                <!-- Results & Navigation -->
                <div class="flex justify-between">
                    <button id="return-to-selection" class="px-3 md:px-4 py-2 text-xs md:text-sm border border-primary text-primary rounded-md hover:bg-primary hover:bg-opacity-10 transition-colors">New Battle</button>
                    <button id="next-turn" class="golden-button px-4 md:px-6 py-2 text-xs md:text-sm rounded-md hover:bg-secondary transition-colors">Next Turn</button>
                </div>
            </div>

            <!-- Results Screen -->
            <div id="results-screen" class="game-screen hidden">
                <div class="text-center mb-4 md:mb-6">
                    <h2 class="text-xl md:text-3xl font-bold mb-1 md:mb-2 golden-neon-text">Battle Results</h2>
                    <div id="winner-announcement" class="text-base md:text-lg font-medium text-primary"></div>
                </div>
                
                <div class="grid grid-cols-1 md:grid-cols-2 gap-4 md:gap-6 mb-6 md:mb-8 perspective-container">
                    <div class="p-3 md:p-4 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border card-3d golden-neon-border">
                        <h3 class="text-base md:text-lg font-medium mb-2 md:mb-3 golden-neon-text">Battle Statistics</h3>
                        <div id="battle-stats" class="space-y-1 md:space-y-2 text-xs md:text-sm">
                            <!-- Battle stats will appear here -->
                        </div>
                    </div>
                    
                    <div class="p-3 md:p-4 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border card-3d golden-neon-border">
                        <h3 class="text-base md:text-lg font-medium mb-2 md:mb-3 golden-neon-text">MVP Character</h3>
                        <div id="mvp-character" class="text-center">
                            <!-- MVP info will appear here -->
                        </div>
                    </div>
                </div>
                
                <div class="mb-4 md:mb-6 p-3 md:p-4 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border golden-neon-border">
                    <h3 class="text-base md:text-lg font-medium mb-2 md:mb-3 golden-neon-text">Battle Summary</h3>
                    <div id="battle-summary" class="text-xs md:text-sm space-y-1 md:space-y-2">
                        <!-- Battle summary will appear here -->
                    </div>
                </div>
                
                <div class="mb-4 md:mb-6 p-3 md:p-4 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border golden-neon-border">
                    <h3 class="text-base md:text-lg font-medium mb-2 md:mb-3 golden-neon-text">Detailed Battle Recap</h3>
                    <div id="battle-recap" class="text-xs md:text-sm space-y-1 md:space-y-2 max-h-64 overflow-y-auto custom-scrollbar">
                        <!-- Battle recap will appear here -->
                    </div>
                </div>
                
                <div class="flex justify-between">
                    <button id="save-battle" class="px-3 md:px-4 py-2 text-xs md:text-sm border border-primary text-primary rounded-md hover:bg-primary hover:bg-opacity-10 transition-colors">Save Battle</button>
                    <button id="play-again" class="golden-button px-4 md:px-6 py-2 text-xs md:text-sm rounded-md hover:bg-secondary transition-colors">Play Again</button>
                </div>
            </div>
            
            <!-- Battle History Screen -->
            <div id="battle-history-screen" class="game-screen hidden">
                <div class="flex justify-between items-center mb-4">
                    <h2 class="text-xl md:text-2xl font-semibold golden-neon-text">Battle History</h2>
                    <button id="back-to-main" class="px-3 py-1 text-xs md:text-sm border border-primary text-primary rounded-md hover:bg-primary hover:bg-opacity-10 transition-colors">Back</button>
                </div>
                
                <div id="battle-records" class="grid grid-cols-1 gap-3 mb-4 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border p-3 md:p-4 golden-neon-border">
                    <p class="text-center opacity-50" id="no-history-message">No battle records found</p>
                    <!-- Battle records will appear here -->
                </div>
            </div>
        </div>
        
        <!-- Chatbot -->
        <div id="chatbot" class="chatbot-container bg-light-card dark:bg-dark-card border border-light-border dark:border-dark-border minimized golden-neon-border">
            <div class="chatbot-header bg-primary text-white flex justify-between items-center" id="chatbot-header">
                <span class="font-medium">Game Assistant</span>
                <button id="minimize-chatbot" class="text-white px-2">
                    <span id="minimize-icon">+</span>
                </button>
            </div>
            <div class="chatbot-messages custom-scrollbar bg-light-bg dark:bg-dark-bg" id="chatbot-messages">
                <div class="message bot-message">
                    Hello! I'm your Epic AI Battle assistant. Ask me anything about the game mechanics, characters, or strategies.
                </div>
            </div>
            <div class="chatbot-input-container flex bg-light-card dark:bg-dark-card">
                <input type="text" id="chatbot-input" placeholder="Ask a question..." class="flex-grow px-3 py-2 text-base bg-transparent border-none outline-none">
                <button id="send-message" class="px-3 text-primary hover:text-secondary transition-colors">
                    Send
                </button>
            </div>
        </div>
    </div>

    <script>
        // Check for dark mode
        if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.documentElement.classList.add('dark');
        }
        
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
            if (event.matches) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        });

        // Game Data
        const characters = [
            // Marvel Universe
            { 
                id: 1, 
                name: "Doctor Strange", 
                universe: "marvel", 
                bp: 86, 
                abilities: ["Mystic Arts", "Time Manipulation", "Astral Projection"],
                skills: [
                    { name: "Mystic Barrier", description: "Create a protective shield reducing damage by 30%", cooldown: 2, type: "defensive" },
                    { name: "Eldritch Magic", description: "Summon mystical energy dealing 15 damage", cooldown: 1, type: "offensive" },
                    { name: "Time Loop", description: "Repeat your last turn's action with 30% increased effectiveness", cooldown: 3, type: "special" }
                ],
                ultimate: "Eye of Agamotto", 
                ultimateEffect: "Rewind time to restore 30% BP to all allies and reset all cooldowns",
                leaderBonus: "All team members gain 10% reduced cooldown times",
                description: "Master of the mystic arts with reality-bending powers",
                combatStyle: {
                    aerial: 0.6,
                    ground: 0.3,
                    coordinate: 0.7,
                    hold: 0.5,
                    adaptive: 0.8
                }
            },
            { 
                id: 2, 
                name: "Scarlet Witch", 
                universe: "marvel", 
                bp: 88, 
                abilities: ["Chaos Magic", "Reality Warping", "Telekinesis"],
                skills: [
                    { name: "Chaos Blast", description: "Unleash chaotic energy dealing 18 damage", cooldown: 1, type: "offensive" },
                    { name: "Mind Control", description: "Force an enemy to skip their next turn", cooldown: 3, type: "control" },
                    { name: "Reality Shift", description: "50% chance to avoid all damage next turn", cooldown: 2, type: "defensive" }
                ],
                ultimate: "Darkhold Corruption", 
                ultimateEffect: "Deal 25 damage to all enemies and apply 'Corrupted' status reducing their BP by 5% each turn for 3 turns",
                leaderBonus: "Team abilities have 20% chance to apply random status effects",
                description: "Chaos magic user with reality-altering abilities",
                combatStyle: {
                    aerial: 0.8,
                    ground: 0.4,
                    coordinate: 0.5,
                    hold: 0.3,
                    adaptive: 0.7
                }
            },
            { 
                id: 3, 
                name: "Thanos", 
                universe: "marvel", 
                bp: 90, 
                abilities: ["Superhuman Strength", "Cosmic Power", "Tactical Genius"],
                skills: [
                    { name: "Titan's Fist", description: "Powerful strike dealing 20 damage", cooldown: 1, type: "offensive" },
                    { name: "Cosmic Throw", description: "Hurl a moon fragment dealing 15 damage and stunning target for 1 turn", cooldown: 3, type: "control" },
                    { name: "Battle Meditation", description: "Increase BP by 10 and gain 'Strengthened' status", cooldown: 2, type: "buff" }
                ],
                ultimate: "Infinity Gauntlet", 
                ultimateEffect: "50% chance to instantly defeat one enemy, or deal 40 damage if it fails",
                leaderBonus: "Team members gain +5 BP at the start of battle and increased critical hit chance",
                description: "The Mad Titan with unparalleled strength and will",
                combatStyle: {
                    aerial: 0.5,
                    ground: 0.9,
                    coordinate: 0.4,
                    hold: 0.7,
                    adaptive: 0.6
                }
            },
            { 
                id: 4, 
                name: "Doctor Doom", 
                universe: "marvel", 
                bp: 87, 
                abilities: ["Sorcery", "Technological Genius", "Iron Will"],
                skills: [
                    { name: "Doom Blast", description: "Energy blast dealing 16 damage", cooldown: 1, type: "offensive" },
                    { name: "Mystical Counter", description: "Next attack against you is reflected back at 70% power", cooldown: 2, type: "defensive" },
                    { name: "Doom's Will", description: "Instantly reset one ally's cooldowns", cooldown: 3, type: "support" }
                ],
                ultimate: "Doom's Decree", 
                ultimateEffect: "Take control of an enemy for one turn, forcing them to attack their allies",
                leaderBonus: "Team gains defensive and offensive bonuses alternating each round",
                description: "Brilliant scientist and sorcerer seeking ultimate power",
                combatStyle: {
                    aerial: 0.5,
                    ground: 0.6,
                    coordinate: 0.7,
                    hold: 0.8,
                    adaptive: 0.5
                }
            },
            { 
                id: 5, 
                name: "Venom", 
                universe: "marvel", 
                bp: 82, 
                abilities: ["Symbiote Bonding", "Superhuman Strength", "Shape-shifting"],
                skills: [
                    { name: "Symbiote Tendrils", description: "Multiple attacks dealing 4-5 damage 3 times", cooldown: 1, type: "offensive" },
                    { name: "Consume", description: "Deal 12 damage and heal for 50% of damage dealt", cooldown: 2, type: "lifesteal" },
                    { name: "We Are Venom", description: "Enter rage mode, increasing damage by 30% for 2 turns", cooldown: 3, type: "buff" }
                ],
                ultimate: "Complete Symbiosis", 
                ultimateEffect: "Heal to full BP and gain immunity to status effects for 2 turns",
                leaderBonus: "Team gains lifesteal abilities, healing for 10% of damage dealt",
                description: "Alien symbiote with a taste for vengeance",
                combatStyle: {
                    aerial: 0.6,
                    ground: 0.8,
                    coordinate: 0.3,
                    hold: 0.4,
                    adaptive: 0.7
                }
            },
            { 
                id: 6, 
                name: "Mr. Fantastic", 
                universe: "marvel", 
                bp: 81, 
                abilities: ["Elastic Body", "Super Intelligence", "Leadership"],
                skills: [
                    { name: "Elastic Punch", description: "Extended range attack dealing 14 damage", cooldown: 1, type: "offensive" },
                    { name: "Tactical Analysis", description: "Identify enemy weakness, increasing team damage by 20% against target", cooldown: 2, type: "support" },
                    { name: "Protective Stretch", description: "Shield an ally, absorbing 50% of damage they would take next turn", cooldown: 2, type: "defensive" }
                ],
                ultimate: "Ultimate Elasticity", 
                ultimateEffect: "Entangle all enemies, reducing their damage output by 40% for 2 turns",
                leaderBonus: "Team gains increased efficiency, all cooldowns reduced by 1",
                description: "Genius scientist with an incredibly elastic body",
                combatStyle: {
                    aerial: 0.5,
                    ground: 0.5,
                    coordinate: 0.9,
                    hold: 0.6,
                    adaptive: 0.7
                }
            },
            
            // DC Universe
            { 
                id: 7, 
                name: "Superman", 
                universe: "dc", 
                bp: 91, 
                abilities: ["Super Strength", "Heat Vision", "Flight"],
                skills: [
                    { name: "Heat Vision", description: "Focused beam dealing 18 damage with 20% burn chance", cooldown: 1, type: "offensive" },
                    { name: "Super Speed", description: "Move so fast you gain an extra action this turn", cooldown: 3, type: "special" },
                    { name: "Invulnerability", description: "Reduce all incoming damage by 40% for 2 turns", cooldown: 2, type: "defensive" }
                ],
                ultimate: "Solar Flare", 
                ultimateEffect: "Unleash stored solar energy dealing 35 damage to all enemies",
                leaderBonus: "Team gains 10% increased BP and damage resistance",
                description: "Last son of Krypton with godlike abilities",
                combatStyle: {
                    aerial: 0.9,
                    ground: 0.7,
                    coordinate: 0.6,
                    hold: 0.5,
                    adaptive: 0.7
                }
            },
            { 
                id: 8, 
                name: "Batman", 
                universe: "dc", 
                bp: 82, 
                abilities: ["Detective Skills", "Martial Arts", "Gadgets"],
                skills: [
                    { name: "Batarang", description: "Thrown projectile dealing 12 damage and reducing target accuracy", cooldown: 1, type: "offensive" },
                    { name: "Smoke Bomb", description: "Deploy smoke screen giving allies 40% evasion chance for 2 turns", cooldown: 2, type: "defensive" },
                    { name: "Preparation", description: "Analyze enemies and gain specific counters to their abilities", cooldown: 2, type: "tactical" }
                ],
                ultimate: "Contingency Protocol", 
                ultimateEffect: "Deploy specific countermeasures against each enemy, reducing their primary abilities by 50% for 3 turns",
                leaderBonus: "Team gains enhanced tactical capabilities, 25% chance to counter any attack",
                description: "Brilliant detective and master strategist",
                combatStyle: {
                    aerial: 0.5,
                    ground: 0.7,
                    coordinate: 0.8,
                    hold: 0.6,
                    adaptive: 0.9
                }
            },
            { 
                id: 9, 
                name: "Wonder Woman", 
                universe: "dc", 
                bp: 88, 
                abilities: ["Godly Strength", "Lasso of Truth", "Combat Mastery"],
                skills: [
                    { name: "Amazon Strike", description: "Powerful melee attack dealing 17 damage", cooldown: 1, type: "offensive" },
                    { name: "Bracers of Submission", description: "Block incoming attacks, reflecting 60% of damage back", cooldown: 2, type: "defensive" },
                    { name: "Lasso of Truth", description: "Bind enemy, preventing them from using special abilities for 2 turns", cooldown: 2, type: "control" }
                ],
                ultimate: "Godkiller", 
                ultimateEffect: "Channel divine power to deal 30 damage and bypass any defensive abilities",
                leaderBonus: "Team gains 15% bonus to all stats and healing capabilities",
                description: "Amazon warrior princess with divine powers",
                combatStyle: {
                    aerial: 0.7,
                    ground: 0.8,
                    coordinate: 0.7,
                    hold: 0.6,
                    adaptive: 0.7
                }
            },
            { 
                id: 10, 
                name: "The Flash", 
                universe: "dc", 
                bp: 85, 
                abilities: ["Super Speed", "Speed Force", "Time Travel"],
                skills: [
                    { name: "Speed Punch", description: "Rapid attack dealing 10 damage 2 times", cooldown: 1, type: "offensive" },
                    { name: "Phase", description: "Become intangible, avoiding all damage next turn", cooldown: 2, type: "defensive" },
                    { name: "Time Remnant", description: "Create a duplicate that performs an additional basic attack", cooldown: 3, type: "special" }
                ],
                ultimate: "Infinite Mass Punch", 
                ultimateEffect: "Near-light speed punch dealing 45 damage to a single target",
                leaderBonus: "Team gains 30% increased speed, allowing occasional double turns",
                description: "Fastest man alive with speed force connection",
                combatStyle: {
                    aerial: 0.6,
                    ground: 0.7,
                    coordinate: 0.5,
                    hold: 0.3,
                    adaptive: 0.8
                }
            },
            { 
                id: 11, 
                name: "Green Lantern", 
                universe: "dc", 
                bp: 84, 
                abilities: ["Power Ring", "Construct Creation", "Willpower"],
                skills: [
                    { name: "Energy Blast", description: "Concentrated willpower blast dealing 15 damage", cooldown: 1, type: "offensive" },
                    { name: "Shield Construct", description: "Create a defensive barrier reducing damage by 35% for all allies", cooldown: 2, type: "defensive" },
                    { name: "Creative Constructs", description: "Form strategic constructs based on battlefield needs", cooldown: 2, type: "tactical" }
                ],
                ultimate: "Emerald Nova", 
                ultimateEffect: "Channel the full power of the ring dealing 25 damage to all enemies with 30% stun chance",
                leaderBonus: "Team constructs provide additional effects based on battle situation",
                description: "Space cop with a ring powered by willpower",
                combatStyle: {
                    aerial: 0.8,
                    ground: 0.5,
                    coordinate: 0.7,
                    hold: 0.6,
                    adaptive: 0.7
                }
            },
            { 
                id: 12, 
                name: "Darkseid", 
                universe: "dc", 
                bp: 90, 
                abilities: ["Omega Beams", "Super Strength", "Immortality"],
                skills: [
                    { name: "Omega Effect", description: "Targeted beams dealing 20 damage with homing capability", cooldown: 1, type: "offensive" },
                    { name: "Boom Tube", description: "Teleport around the battlefield avoiding damage and repositioning", cooldown: 2, type: "defensive" },
                    { name: "Lord of Apokolips", description: "Summon parademons to deal 8 damage to all enemies", cooldown: 3, type: "special" }
                ],
                ultimate: "Anti-Life Equation", 
                ultimateEffect: "Dominate enemy minds, taking control of all enemies for one turn",
                leaderBonus: "Team gains ruthless efficiency, increasing damage by 20% against weakened targets",
                description: "Lord of Apokolips seeking the Anti-Life Equation",
                combatStyle: {
                    aerial: 0.6,
                    ground: 0.8,
                    coordinate: 0.5,
                    hold: 0.7,
                    adaptive: 0.6
                }
            },
            
            // Other Universes
            { 
                id: 13, 
                name: "Zeus", 
                universe: "other", 
                bp: 89, 
                abilities: ["Lightning Control", "Divine Strength", "Weather Manipulation"],
                skills: [
                    { name: "Lightning Strike", description: "Call down lightning dealing 19 damage with 30% stun chance", cooldown: 1, type: "offensive" },
                    { name: "Divine Aura", description: "Surround yourself with divine energy, reducing damage by 40%", cooldown: 2, type: "defensive" },
                    { name: "Storm Lord", description: "Create a storm dealing 10 damage to all enemies for 2 turns", cooldown: 3, type: "area" }
                ],
                ultimate: "Divine Thunder", 
                ultimateEffect: "Channel godly wrath, dealing 40 damage and guaranteeing stun",
                leaderBonus: "Team gains elemental affinities, adding lightning damage to all attacks",
                description: "King of the Greek gods with control over lightning",
                combatStyle: {
                    aerial: 0.8,
                    ground: 0.5,
                    coordinate: 0.6,
                    hold: 0.7,
                    adaptive: 0.7
                }
            },
            { 
                id: 14, 
                name: "Michael", 
                universe: "other", 
                bp: 90, 
                abilities: ["Holy Light", "Divine Protection", "Flight"],
                skills: [
                    { name: "Holy Smite", description: "Divine punishment dealing 18 damage", cooldown: 1, type: "offensive" },
                    { name: "Angelic Guard", description: "Protect allies, reducing damage taken by 30% for 2 turns", cooldown: 2, type: "defensive" },
                    { name: "Purification", description: "Remove all negative status effects from allies and heal 10 BP", cooldown: 3, type: "healing" }
                ],
                ultimate: "Heavenly Judgment", 
                ultimateEffect: "Divine judgment dealing 30 damage to all enemies and healing allies for 20 BP",
                leaderBonus: "Team gains holy protection, 20% chance to negate any damage or status effect",
                description: "Archangel with command over heavenly forces",
                combatStyle: {
                    aerial: 0.9,
                    ground: 0.4,
                    coordinate: 0.7,
                    hold: 0.6,
                    adaptive: 0.5
                }
            },
            { 
                id: 15, 
                name: "Harry Potter", 
                universe: "other", 
                bp: 79, 
                abilities: ["Wizardry", "Parseltongue", "Patronus"],
                skills: [
                    { name: "Stunning Spell", description: "Cast Stupefy dealing 12 damage with 25% stun chance", cooldown: 1, type: "offensive" },
                    { name: "Shield Charm", description: "Cast Protego creating a magical barrier reducing damage by 25%", cooldown: 1, type: "defensive" },
                    { name: "Disarming Charm", description: "Cast Expelliarmus preventing target from using special abilities for 1 turn", cooldown: 2, type: "control" }
                ],
                ultimate: "Expecto Patronum", 
                ultimateEffect: "Summon a stag Patronus that protects allies and deals 20 damage to all enemies",
                leaderBonus: "Team spells have increased potency and reduced cooldowns",
                description: "The Boy Who Lived, master of defensive magic",
                combatStyle: {
                    aerial: 0.5,
                    ground: 0.6,
                    coordinate: 0.8,
                    hold: 0.5,
                    adaptive: 0.7
                }
            },
            { 
                id: 16, 
                name: "Gandalf", 
                universe: "other", 
                bp: 86, 
                abilities: ["Istari Magic", "Light of Eärendil", "Ancient Wisdom"],
                skills: [
                    { name: "Magical Staff", description: "Channeled magic dealing 15 damage", cooldown: 1, type: "offensive" },
                    { name: "You Shall Not Pass", description: "Create a barrier preventing enemies from acting for 1 turn", cooldown: 3, type: "control" },
                    { name: "Words of Power", description: "Ancient incantation that boosts all allies' abilities by 20% for 2 turns", cooldown: 2, type: "buff" }
                ],
                ultimate: "White Flame of Anor", 
                ultimateEffect: "Unleash the full power of the Istari, dealing 30 damage to all enemies and removing buffs",
                leaderBonus: "Team gains wisdom and foresight, providing tactical advantages each turn",
                description: "The White Wizard and guardian of Middle-earth",
                combatStyle: {
                    aerial: 0.5,
                    ground: 0.6,
                    coordinate: 0.7,
                    hold: 0.8,
                    adaptive: 0.6
                }
            },
            { 
                id: 17, 
                name: "Goku", 
                universe: "other", 
                bp: 90, 
                abilities: ["Ki Manipulation", "Super Saiyan", "Martial Arts"],
                skills: [
                    { name: "Kamehameha", description: "Energy beam dealing 18 damage", cooldown: 1, type: "offensive" },
                    { name: "Instant Transmission", description: "Teleport to avoid damage and reposition", cooldown: 2, type: "defensive" },
                    { name: "Kaioken", description: "Multiply power, increasing damage by 30% for 2 turns at the cost of 5 BP", cooldown: 2, type: "buff" }
                ],
                ultimate: "Spirit Bomb", 
                ultimateEffect: "Gather energy from surroundings to deal 50 damage to a single target",
                leaderBonus: "Team gains fighting spirit, increasing BP when health is low",
                description: "Saiyan warrior with boundless potential",
                combatStyle: {
                    aerial: 0.8,
                    ground: 0.8,
                    coordinate: 0.5,
                    hold: 0.5,
                    adaptive: 0.9
                }
            },
            { 
                id: 18, 
                name: "Kratos", 
                universe: "other", 
                bp: 88, 
                abilities: ["God-like Strength", "Weapon Mastery", "Spartan Rage"],
                skills: [
                    { name: "Blades of Chaos", description: "Chained blade attack dealing 17 damage", cooldown: 1, type: "offensive" },
                    { name: "Guardian Shield", description: "Block and counter attack, reflecting 40% of incoming damage", cooldown: 2, type: "defensive" },
                    { name: "Spartan Rage", description: "Enter rage mode, increasing damage by 40% for 2 turns", cooldown: 3, type: "buff" }
                ],
                ultimate: "Rage of Sparta", 
                ultimateEffect: "Unleash godly wrath dealing 35 damage to all enemies and gaining temporary invulnerability",
                leaderBonus: "Team gains vengeful spirit, dealing 25% more damage when allies are defeated",
                description: "Former God of War seeking vengeance against Olympus",
                combatStyle: {
                    aerial: 0.4,
                    ground: 0.9,
                    coordinate: 0.3,
                    hold: 0.7,
                    adaptive: 0.5
                }
            }
        ];

        // Synergy definitions
        const synergies = [
            { id: 1, name: "Mystic Arts", characters: [1, 2, 4, 16], bonus: "Increased magical damage and reduced cooldowns", effect: { damageMultiplier: 1.2, cooldownReduction: 1 } },
            { id: 2, name: "Cosmic Power", characters: [1, 3, 7, 17], bonus: "Enhanced ultimate abilities and energy regeneration", effect: { ultimateDamageBonus: 1.3, energyRegen: 0.1 } },
            { id: 3, name: "Gods Among Us", characters: [13, 14, 18], bonus: "Divine protection and increased attack power", effect: { damageReduction: 0.15, damageMultiplier: 1.15 } },
            { id: 4, name: "Marvel Titans", characters: [2, 3, 4, 5], bonus: "Increased team coordination and defensive bonuses", effect: { defenseBonus: 0.2, counterAttackChance: 0.25 } },
            { id: 5, name: "DC Legends", characters: [7, 8, 9, 10, 11], bonus: "Justice League coordination and combo attacks", effect: { comboChance: 0.3, healingBonus: 0.2 } },
            { id: 6, name: "Ultimate Intellects", characters: [1, 4, 6, 8], bonus: "Strategic advantages and counter-attack opportunities", effect: { criticalHitChance: 0.2, tacticalBonus: 0.15 } },
            { id: 7, name: "Elemental Masters", characters: [2, 11, 13, 15], bonus: "Control over natural forces and increased area damage", effect: { areaDamageBonus: 0.25, statusEffectChance: 0.2 } },
            { id: 8, name: "Tactical Leaders", characters: [6, 8, 9, 16], bonus: "Improved team coordination and strategic planning", effect: { cooldownReduction: 1, supportBonus: 0.25 } },
            { id: 9, name: "Supernatural Powers", characters: [1, 2, 4, 14, 15, 16], bonus: "Enhanced mystical abilities and resistance to control effects", effect: { magicDamageBonus: 0.2, controlResistance: 0.3 } },
            { id: 10, name: "Raw Power", characters: [3, 5, 7, 12, 17, 18], bonus: "Overwhelming strength and increased damage output", effect: { damageMultiplier: 1.25, ultimateChargeRate: 0.2 } }
        ];

        // Status Effects
        const statusEffects = {
            stunned: { name: "Stunned", description: "Cannot perform actions", icon: "⚡", duration: 1 },
            poisoned: { name: "Poisoned", description: "Takes damage over time", icon: "☠️", duration: 3 },
            burned: { name: "Burned", description: "Takes damage over time and reduced attack", icon: "🔥", duration: 2 },
            frozen: { name: "Frozen", description: "Reduced speed and damage", icon: "❄️", duration: 2 },
            strengthened: { name: "Strengthened", description: "Increased damage output", icon: "💪", duration: 2 },
            protected: { name: "Protected", description: "Reduced damage taken", icon: "🛡️", duration: 2 },
            regenerating: { name: "Regenerating", description: "Recovers BP over time", icon: "💚", duration: 3 },
            cursed: { name: "Cursed", description: "Cannot use special abilities", icon: "⚱️", duration: 2 },
            blessed: { name: "Blessed", description: "Increased healing and status resistance", icon: "✨", duration: 2 },
            vulnerable: { name: "Vulnerable", description: "Takes increased damage", icon: "🎯", duration: 2 }
        };

        // Battle styles
        const battleStyles = {
            "aerial-assault": {
                name: "Aerial Assault",
                description: "Attack from above with increased speed and evasion",
                effects: {
                    damageMultiplier: 1.2,
                    evasionChance: 0.2,
                    speedBonus: 0.3,
                    defenseReduction: 0.1
                },
                animation: "aerial"
            },
            "ground-assault": {
                name: "Ground Assault",
                description: "Focus on powerful close combat with increased damage",
                effects: {
                    damageMultiplier: 1.3,
                    criticalHitChance: 0.15,
                    speedReduction: 0.1,
                    defenseBonus: 0.1
                },
                animation: "ground"
            },
            "coordinate-attacks": {
                name: "Coordinate Attacks",
                description: "Team-based combo opportunities and tactical advantages",
                effects: {
                    comboChance: 0.3,
                    teamDamageBonus: 0.15,
                    cooldownReduction: 1,
                    tacticalBonus: 0.2
                },
                animation: "coordinate"
            },
            "hold-your-ground": {
                name: "Hold Your Ground",
                description: "Defensive stance with counter-attacks and damage reduction",
                effects: {
                    damageReduction: 0.25,
                    counterAttackChance: 0.4,
                    healingBonus: 0.2,
                    damageReduction: 0.15
                },
                animation: "hold-ground"
            },
            "play-by-ear": {
                name: "Play By Ear",
                description: "Adapt to situations dynamically with varied bonuses",
                effects: {
                    adaptiveDamage: 0.2,
                    adaptiveDefense: 0.2,
                    statusEffectChance: 0.2,
                    cooldownReduction: 0.5
                },
                animation: "play-by-ear"
            }
        };

        // Team strategies
        const teamStrategies = {
            offensive: {
                name: "Offensive",
                description: "Focus on dealing maximum damage with reduced defense",
                effects: {
                    damageMultiplier: 1.3,
                    criticalHitChance: 0.15,
                    defenseReduction: 0.15,
                    speedBonus: 0.1
                }
            },
            defensive: {
                name: "Defensive",
                description: "Prioritize survival and damage reduction over offense",
                effects: {
                    damageReduction: 0.25,
                    healingBonus: 0.2,
                    counterAttackChance: 0.2,
                    damageReduction: 0.1
                }
            },
            balanced: {
                name: "Balanced",
                description: "Equal focus on offense and defense with no weaknesses",
                effects: {
                    damageMultiplier: 1.1,
                    damageReduction: 0.1,
                    cooldownReduction: 0.5,
                    statusResistance: 0.15
                }
            }
        };

        // Sound effects mapping
        const soundEffects = {
            attack: document.getElementById('attack-sound'),
            ultimate: document.getElementById('ultimate-sound'),
            victory: document.getElementById('victory-sound'),
            defeat: document.getElementById('defeat-sound')
        };

        // Game state
        let gameState = {
            screen: 'team-selection',
            playerTeam: [],
            aiTeam: [],
            activeSynergies: [],
            leaderId: null,
            teamStrategy: 'balanced',
            aiTeamStrategy: null,
            battleStyle: 'aerial-assault',
            activeCharacterIndex: 0,
            selectedAction: null,
            selectedSkill: null,
            round: 1,
            turn: 1,
            battleLog: [],
            errorLog: [],
            battleStats: {
                roundsPlayed: 0,
                damageDealt: { player: 0, ai: 0 },
                healingDone: { player: 0, ai: 0 },
                criticalHits: { player: 0, ai: 0 },
                ultimatesUsed: { player: 0, ai: 0 },
                skillsUsed: { player: 0, ai: 0 },
                statusEffectsApplied: { player: 0, ai: 0 }
            },
            winner: null,
            mvp: null,
            theme: 'default',
            aspectRatio: 'auto',
            battleHistory: [],
            soundEnabled: true,
            volume: 0.7
        };

        // DOM references
        const screens = {
            teamSelection: document.getElementById('team-selection-screen'),
            battle: document.getElementById('battle-screen'),
            results: document.getElementById('results-screen'),
            battleHistory: document.getElementById('battle-history-screen')
        };

        // Initialize game
        document.addEventListener('DOMContentLoaded', () => {
            initializeGame();
            setupEventListeners();
            initializeChatbot();
            initializeAudio();
            initializeParticles();
            init3DEffects();
        });

        function initializeGame() {
            populateCharacterSelection();
            setupUniverseFilters();
            loadBattleHistory();
        }

        function setupEventListeners() {
            // Theme and aspect ratio selectors
            document.getElementById('theme-default').addEventListener('click', () => setTheme('default'));
            document.getElementById('theme-golden-hour').addEventListener('click', () => setTheme('golden-hour'));
            
            document.querySelectorAll('.aspect-selector input').forEach(input => {
                input.addEventListener('change', (e) => setAspectRatio(e.target.value));
            });
            
            // Team selection events
            document.getElementById('reset-team').addEventListener('click', resetTeam);
            document.getElementById('start-battle').addEventListener('click', startBattle);
            document.getElementById('battle-history').addEventListener('click', () => changeScreen('battleHistory'));
            document.getElementById('back-to-main').addEventListener('click', () => changeScreen('teamSelection'));
            
            // Strategy selection
            document.querySelectorAll('.strategy-option').forEach(option => {
                option.addEventListener('click', () => selectStrategy(option.dataset.strategy));
            });
            
            // Battle style selection
            document.querySelectorAll('.battle-style-option').forEach(option => {
                option.addEventListener('click', () => selectBattleStyle(option.dataset.style));
            });
            
            // Battle screen events
            document.querySelectorAll('.action-btn').forEach(btn => {
                btn.addEventListener('click', () => selectAction(btn.dataset.action));
            });
            document.getElementById('back-to-actions').addEventListener('click', showActionSelection);
            document.getElementById('back-to-actions-from-skills').addEventListener('click', showActionSelection);
            document.getElementById('next-turn').addEventListener('click', processTurn);
            document.getElementById('return-to-selection').addEventListener('click', returnToTeamSelection);
            document.getElementById('toggle-error-log').addEventListener('click', toggleErrorLog);
            
            // Results screen events
            document.getElementById('play-again').addEventListener('click', returnToTeamSelection);
            document.getElementById('save-battle').addEventListener('click', saveBattleToHistory);
            
            // Chatbot events
            document.getElementById('chatbot-header').addEventListener('click', toggleChatbot);
            document.getElementById('send-message').addEventListener('click', sendChatbotMessage);
            document.getElementById('chatbot-input').addEventListener('keypress', e => {
                if(e.key === 'Enter') sendChatbotMessage();
            });
            
            // Audio player events
            document.getElementById('play-pause-btn').addEventListener('click', toggleMusic);
            document.getElementById('volume-control').addEventListener('input', adjustVolume);
        }

        function initializeAudio() {
            // Set initial volume
            const volumeControl = document.getElementById('volume-control');
            const battleTheme = document.getElementById('battle-theme');
            
            battleTheme.volume = gameState.volume;
            volumeControl.value = gameState.volume * 100;
            
            // Set volumes for sound effects too
            Object.values(soundEffects).forEach(sound => {
                sound.volume = gameState.volume * 0.8; // Slightly lower than music
            });
        }

        function toggleMusic() {
            const battleTheme = document.getElementById('battle-theme');
            const playPauseBtn = document.getElementById('play-pause-btn');
            
            if (battleTheme.paused) {
                battleTheme.play();
                playPauseBtn.textContent = '❚❚';
                gameState.soundEnabled = true;
            } else {
                battleTheme.pause();
                playPauseBtn.textContent = '▶';
                gameState.soundEnabled = false;
            }
        }

        function adjustVolume(e) {
            const volume = e.target.value / 100;
            const battleTheme = document.getElementById('battle-theme');
            
            battleTheme.volume = volume;
            gameState.volume = volume;
            
            // Update sound effect volumes too
            Object.values(soundEffects).forEach(sound => {
                sound.volume = volume * 0.8; // Slightly lower than music
            });
        }

        function playSound(soundType) {
            if (!gameState.soundEnabled) return;
            
            const sound = soundEffects[soundType];
            if (sound) {
                sound.currentTime = 0;
                sound.play();
            }
        }

        function initializeParticles() {
            const container = document.getElementById('particles-container');
            
            // Create golden particles
            for (let i = 0; i < 30; i++) {
                createParticle(container);
            }
            
            // Add more particles periodically
            setInterval(() => {
                if (container.children.length < 30) {
                    createParticle(container);
                }
            }, 2000);
        }

        function createParticle(container) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            
            // Random size
            const size = Math.random() * 10 + 5;
            particle.style.width = `${size}px`;
            particle.style.height = `${size}px`;
            
            // Random position
            particle.style.left = `${Math.random() * 100}%`;
            particle.style.top = `${Math.random() * 100}%`;
            
            // Random animation delay
            particle.style.animationDelay = `${Math.random() * 5}s`;
            
            // Random animation duration
            particle.style.animationDuration = `${Math.random() * 5 + 3}s`;
            
            // Add to container
            container.appendChild(particle);
            
            // Remove after animation completes
            setTimeout(() => {
                if (container.contains(particle)) {
                    container.removeChild(particle);
                }
            }, 8000);
        }

        function init3DEffects() {
            // Add 3D mouse movement effect to cards
            document.addEventListener('mousemove', function(e) {
                const cards = document.querySelectorAll('.card-3d');
                
                cards.forEach(card => {
                    // Get dimensions and position of card
                    const rect = card.getBoundingClientRect();
                    
                    // Calculate mouse position relative to card center
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const mouseX = e.clientX - centerX;
                    const mouseY = e.clientY - centerY;
                    
                    // Only apply effect when mouse is near the card
                    const distance = Math.sqrt(mouseX * mouseX + mouseY * mouseY);
                    const maxDistance = Math.max(rect.width, rect.height);
                    
                    if (distance < maxDistance * 1.5) {
                        // Calculate rotation angle based on mouse position
                        const rotateY = mouseX * 0.05;
                        const rotateX = -mouseY * 0.05;
                        
                        // Apply subtle transformation
                        card.style.transform = `rotateY(${rotateY}deg) rotateX(${rotateX}deg) translateZ(5px)`;
                    } else {
                        // Reset when mouse is far away
                        card.style.transform = 'rotateY(0) rotateX(0) translateZ(0)';
                    }
                });
            });
        }

        function setTheme(theme) {
            // Remove existing theme classes
            document.body.classList.remove('theme-golden-hour');
            
            // Add new theme class
            if (theme === 'golden-hour') {
                document.body.classList.add('theme-golden-hour');
            }
            
            gameState.theme = theme;
            
            // Update neon elements
            updateGoldenNeonEffects();
        }

        function updateGoldenNeonEffects() {
            // Update buttons and headings
            const glowElements = document.querySelectorAll('.golden-glow');
            const isGoldenHour = gameState.theme === 'golden-hour';
            
            glowElements.forEach(element => {
                if (isGoldenHour) {
                    element.style.boxShadow = '0 0 15px rgba(249, 149, 0, 0.7), 0 0 25px rgba(249, 149, 0, 0.5)';
                } else {
                    element.style.boxShadow = '0 0 15px rgba(255, 215, 0, 0.6), 0 0 25px rgba(255, 215, 0, 0.4)';
                }
            });
            
            // Update text glows
            const textElements = document.querySelectorAll('.golden-neon-text');
            textElements.forEach(element => {
                if (isGoldenHour) {
                    element.style.color = '#F99500';
                    element.style.textShadow = '0 0 10px rgba(249, 149, 0, 0.7), 0 0 15px rgba(249, 149, 0, 0.5)';
                } else {
                    element.style.color = '#FFD700';
                    element.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.7), 0 0 15px rgba(255, 215, 0, 0.5)';
                }
            });
        }

        function setAspectRatio(ratio) {
            const app = document.getElementById('app');
            
            // Remove existing aspect classes
            app.classList.remove('aspect-square', 'aspect-video', 'aspect-4/3');
            
            // Apply new aspect ratio
            if (ratio === 'square') {
                app.classList.add('aspect-square');
            } else if (ratio === 'classic') {
                app.classList.add('aspect-4/3');
            } else if (ratio === 'wide') {
                app.classList.add('aspect-video');
            }
            
            gameState.aspectRatio = ratio;
        }

        function populateCharacterSelection() {
            const selectionGrid = document.getElementById('character-selection');
            selectionGrid.innerHTML = '';
            
            characters.forEach(character => {
                const card = document.createElement('div');
                card.className = `character-card p-3 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border cursor-pointer hover:border-primary transition-all card-3d rotate-on-hover`;
                card.dataset.characterId = character.id;
                
                // Calculate average skill rating for display
                const skillPower = character.skills.reduce((total, skill) => {
                    return total + (skill.type === 'offensive' ? 4 : skill.type === 'defensive' ? 3 : 2);
                }, 0) / character.skills.length;
                
                card.innerHTML = `
                    <div class="card-3d-content">
                        <div class="flex justify-between items-start mb-2">
                            <h3 class="font-medium text-sm md:text-base">${character.name}</h3>
                            <span class="px-2 py-0.5 text-xs rounded-full bg-primary bg-opacity-20">BP: ${character.bp}</span>
                        </div>
                        <div class="text-xs opacity-75 mb-2">${character.universe.charAt(0).toUpperCase() + character.universe.slice(1)} Universe</div>
                        <p class="text-xs mb-2 line-clamp-2">${character.description}</p>
                        <div class="text-xs flex justify-between">
                            <div><span class="font-medium">Ultimate:</span> ${character.ultimate}</div>
                            <div><span class="font-medium">Skills:</span> ${Math.round(skillPower)}/5</div>
                        </div>
                    </div>
                `;
                
                card.addEventListener('click', () => toggleCharacterSelection(character));
                selectionGrid.appendChild(card);
            });
        }

        function setupUniverseFilters() {
            const filterButtons = document.querySelectorAll('.universe-filter');
            
            filterButtons.forEach(button => {
                button.addEventListener('click', () => {
                    // Toggle active state
                    filterButtons.forEach(btn => {
                        btn.classList.remove('bg-primary', 'golden-glow');
                        btn.classList.add('bg-opacity-10');
                    });
                    button.classList.add('bg-primary', 'golden-glow');
                    button.classList.remove('bg-opacity-10');
                    
                    // Apply filter
                    const universe = button.dataset.universe;
                    filterCharactersByUniverse(universe);
                });
            });
            
            // Set "All" as default active filter
            filterButtons[0].click();
        }

        function filterCharactersByUniverse(universe) {
            const characterCards = document.querySelectorAll('.character-card');
            
            characterCards.forEach(card => {
                const characterId = parseInt(card.dataset.characterId);
                const character = characters.find(c => c.id === characterId);
                
                if (universe === 'all' || character.universe === universe) {
                    card.classList.remove('hidden');
                } else {
                    card.classList.add('hidden');
                }
            });
        }

        function toggleCharacterSelection(character) {
            if (gameState.playerTeam.some(c => c.id === character.id)) {
                // Remove character from team
                gameState.playerTeam = gameState.playerTeam.filter(c => c.id !== character.id);
                
                // If the character was the leader, remove leader
                if (gameState.leaderId === character.id) {
                    gameState.leaderId = null;
                }
                
                // Play sound
                playSound('attack');
                
            } else if (gameState.playerTeam.length < 3) {
                // Add character to team with full properties for battle
                gameState.playerTeam.push({
                    ...character, 
                    currentBp: character.bp, 
                    isUltimateReady: false, 
                    ultimateCharge: 0,
                    cooldowns: {},
                    statusEffects: [],
                    defending: false,
                    damageDealt: 0,
                    healingDone: 0,
                    actionsPerformed: 0
                });
                
                // Play sound
                playSound('attack');
                
            } else {
                // Team is full
                try {
                    showErrorMessage('Your team is already full! Remove a character first.');
                } catch (e) {
                    alert('Your team is already full! Remove a character first.');
                }
                return;
            }
            
            updateTeamDisplay();
            updateCharacterCardStyles();
            updateSynergyInfo();
            
            // Show or hide leader and strategy selection
            if (gameState.playerTeam.length === 3) {
                document.getElementById('leader-selection').classList.remove('hidden');
                document.getElementById('strategy-selection').classList.remove('hidden');
                document.getElementById('battle-style-selection').classList.remove('hidden');
                showLeaderOptions();
            } else {
                document.getElementById('leader-selection').classList.add('hidden');
                document.getElementById('strategy-selection').classList.add('hidden');
                document.getElementById('battle-style-selection').classList.add('hidden');
            }
            
            // Enable/disable start button
            document.getElementById('start-battle').disabled = gameState.playerTeam.length !== 3;
        }

        function showLeaderOptions() {
            const leaderContainer = document.getElementById('leader-options');
            leaderContainer.innerHTML = '';
            
            gameState.playerTeam.forEach(character => {
                const option = document.createElement('div');
                option.className = `p-3 bg-light-card dark:bg-dark-card rounded-lg border ${gameState.leaderId === character.id ? 'border-primary golden-glow' : 'border-light-border dark:border-dark-border'} cursor-pointer hover:border-primary transition-all card-3d`;
                option.dataset.characterId = character.id;
                
                option.innerHTML = `
                    <div class="card-3d-content">
                        <div class="flex justify-between items-start mb-1">
                            <h4 class="font-medium text-sm">${character.name}</h4>
                            <span class="text-xs bg-primary bg-opacity-20 px-2 py-0.5 rounded-full">BP: ${character.bp}</span>
                        </div>
                        <div class="text-xs mb-2">${character.leaderBonus}</div>
                    </div>
                `;
                
                option.addEventListener('click', () => selectLeader(character.id));
                leaderContainer.appendChild(option);
            });
        }

        function selectLeader(characterId) {
            gameState.leaderId = characterId;
            
            // Play sound
            playSound('attack');
            
            // Update leader option styles
            document.querySelectorAll('#leader-options > div').forEach(option => {
                if (parseInt(option.dataset.characterId) === characterId) {
                    option.classList.remove('border-light-border', 'dark:border-dark-border');
                    option.classList.add('border-primary', 'golden-glow');
                } else {
                    option.classList.remove('border-primary', 'golden-glow');
                    option.classList.add('border-light-border', 'dark:border-dark-border');
                }
            });
        }

        function selectStrategy(strategy) {
            gameState.teamStrategy = strategy;
            
            // Play sound
            playSound('attack');
            
            // Update strategy option styles
            document.querySelectorAll('.strategy-option').forEach(option => {
                if (option.dataset.strategy === strategy) {
                    option.classList.remove('border-light-border', 'dark:border-dark-border');
                    option.classList.add('border-primary', 'golden-glow');
                } else {
                    option.classList.remove('border-primary', 'golden-glow');
                    option.classList.add('border-light-border', 'dark:border-dark-border');
                }
            });
        }

        function selectBattleStyle(style) {
            gameState.battleStyle = style;
            
            // Play sound
            playSound('attack');
            
            // Update battle style option styles
            document.querySelectorAll('.battle-style-option').forEach(option => {
                if (option.dataset.style === style) {
                    option.classList.remove('border-light-border', 'dark:border-dark-border');
                    option.classList.add('border-primary', 'golden-glow');
                } else {
                    option.classList.remove('border-primary', 'golden-glow');
                    option.classList.add('border-light-border', 'dark:border-dark-border');
                }
            });
        }

        function updateTeamDisplay() {
            const teamContainer = document.getElementById('selected-team');
            const emptyMessage = document.getElementById('empty-team-message');
            
            if (gameState.playerTeam.length === 0) {
                emptyMessage.classList.remove('hidden');
                teamContainer.querySelectorAll('.selected-character-card').forEach(el => el.remove());
                return;
            }
            
            emptyMessage.classList.add('hidden');
            teamContainer.querySelectorAll('.selected-character-card').forEach(el => el.remove());
            
            gameState.playerTeam.forEach(character => {
                const card = document.createElement('div');
                card.className = 'selected-character-card p-3 bg-primary bg-opacity-10 rounded-lg border border-primary flex-1 min-w-[120px] card-3d golden-glow';
                
                // Show character skills on hover
                const skillsList = character.skills.map(skill => 
                    `<div class="mb-1"><span class="font-medium">${skill.name}</span> - ${skill.description}</div>`
                ).join('');
                
                card.innerHTML = `
                    <div class="card-3d-content">
                        <div class="flex justify-between items-start mb-1">
                            <h4 class="font-medium text-sm">${character.name}</h4>
                            <span class="text-xs bg-primary bg-opacity-20 px-2 py-0.5 rounded-full">BP: ${character.bp}</span>
                        </div>
                        <div class="text-xs mb-2">${character.universe.charAt(0).toUpperCase() + character.universe.slice(1)}</div>
                        <div class="hidden skills-tooltip absolute z-10 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border p-2 text-xs w-60 shadow-lg">
                            <h5 class="font-medium mb-1">Skills:</h5>
                            ${skillsList}
                            <div class="font-medium mt-1">Ultimate: ${character.ultimate}</div>
                            <div class="text-xs mt-1">${character.ultimateEffect}</div>
                        </div>
                        <div class="flex justify-end">
                            <button class="remove-character text-xs text-primary hover:underline" data-character-id="${character.id}">Remove</button>
                        </div>
                    </div>
                `;
                
                teamContainer.appendChild(card);
                
                // Add hover event for skills tooltip
                const tooltip = card.querySelector('.skills-tooltip');
                card.addEventListener('mouseenter', () => {
                    tooltip.style.left = '0px';
                    tooltip.style.top = '100%';
                    tooltip.classList.remove('hidden');
                });
                card.addEventListener('mouseleave', () => {
                    tooltip.classList.add('hidden');
                });
            });
            
            // Add event listeners to remove buttons
            teamContainer.querySelectorAll('.remove-character').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const characterId = parseInt(btn.dataset.characterId);
                    
                    // Play sound
                    playSound('attack');
                    
                    // If removing leader, clear leader
                    if (characterId === gameState.leaderId) {
                        gameState.leaderId = null;
                    }
                    
                    gameState.playerTeam = gameState.playerTeam.filter(c => c.id !== characterId);
                    updateTeamDisplay();
                    updateCharacterCardStyles();
                    updateSynergyInfo();
                    
                    // Hide leader and strategy selection if team is not full
                    if (gameState.playerTeam.length < 3) {
                        document.getElementById('leader-selection').classList.add('hidden');
                        document.getElementById('strategy-selection').classList.add('hidden');
                        document.getElementById('battle-style-selection').classList.add('hidden');
                    } else {
                        showLeaderOptions();
                    }
                    
                    // Enable/disable start button
                    document.getElementById('start-battle').disabled = gameState.playerTeam.length !== 3;
                });
            });
        }

        function updateCharacterCardStyles() {
            const characterCards = document.querySelectorAll('.character-card');
            
            characterCards.forEach(card => {
                const characterId = parseInt(card.dataset.characterId);
                if (gameState.playerTeam.some(c => c.id === characterId)) {
                    card.classList.add('selected');
                } else {
                    card.classList.remove('selected');
                }
            });
        }

        function updateSynergyInfo() {
            const synergyContainer = document.getElementById('team-synergy');
            synergyContainer.innerHTML = '';
            
            if (gameState.playerTeam.length === 0) {
                return;
            }
            
            // Find active synergies
            gameState.activeSynergies = [];
            const teamIds = gameState.playerTeam.map(c => c.id);
            
            synergies.forEach(synergy => {
                const matchCount = synergy.characters.filter(id => teamIds.includes(id)).length;
                const total = synergy.characters.length;
                
                if (matchCount >= 2) {
                    const isActive = matchCount >= Math.min(3, Math.ceil(total / 2));
                    gameState.activeSynergies.push({
                        ...synergy,
                        active: isActive,
                        matchCount,
                        totalCount: total
                    });
                }
            });
            
            // Display synergy info
            if (gameState.activeSynergies.length === 0) {
                synergyContainer.innerHTML = '<p class="opacity-50">No team synergies found</p>';
                return;
            }
            
            gameState.activeSynergies.forEach(synergy => {
                const synergyEl = document.createElement('div');
                synergyEl.className = `py-1 ${synergy.active ? 'text-primary' : 'opacity-50'}`;
                
                synergyEl.innerHTML = `
                    <div class="flex justify-between items-center">
                        <span class="font-medium ${synergy.active ? 'golden-neon-text' : ''}">${synergy.name}</span>
                        <span class="text-xs">${synergy.matchCount}/${synergy.totalCount} characters</span>
                    </div>
                    ${synergy.active ? `<p class="text-xs">${synergy.bonus}</p>` : ''}
                `;
                
                synergyContainer.appendChild(synergyEl);
            });
        }

        function resetTeam() {
            gameState.playerTeam = [];
            gameState.leaderId = null;
            gameState.teamStrategy = 'balanced';
            gameState.battleStyle = 'aerial-assault';
            
            // Play sound
            playSound('attack');
            
            // Reset UI
            updateTeamDisplay();
            updateCharacterCardStyles();
            updateSynergyInfo();
            
            // Reset strategy options
            document.querySelectorAll('.strategy-option').forEach(option => {
                option.classList.remove('border-primary', 'golden-glow');
                option.classList.add('border-light-border', 'dark:border-dark-border');
            });
            document.querySelector('.strategy-option[data-strategy="balanced"]').classList.add('border-primary', 'golden-glow');
            
            // Reset battle style options
            document.querySelectorAll('.battle-style-option').forEach(option => {
                option.classList.remove('border-primary', 'golden-glow');
                option.classList.add('border-light-border', 'dark:border-dark-border');
            });
            document.querySelector('.battle-style-option[data-style="aerial-assault"]').classList.add('border-primary', 'golden-glow');
            
            // Hide leader and strategy selection
            document.getElementById('leader-selection').classList.add('hidden');
            document.getElementById('strategy-selection').classList.add('hidden');
            document.getElementById('battle-style-selection').classList.add('hidden');
            
            document.getElementById('start-battle').disabled = true;
        }

        function startBattle() {
            if (gameState.playerTeam.length !== 3) {
                return;
            }
            
            // Start battle music
            const battleTheme = document.getElementById('battle-theme');
            const playPauseBtn = document.getElementById('play-pause-btn');
            battleTheme.play();
            playPauseBtn.textContent = '❚❚';
            
            // Play sound
            playSound('ultimate');
            
            // Create AI team
            generateAITeam();
            
            // Setup battle screen
            setupBattleScreen();
            
            // Switch to battle screen
            changeScreen('battle');
            
            // Initialize battle
            initializeBattle();
        }

        function generateAITeam() {
            gameState.aiTeam = [];
            
            // Filter out player's characters
            const availableCharacters = characters.filter(c => !gameState.playerTeam.some(pc => pc.id === c.id));
            
            // Get average BP of player team
            const playerAvgBP = gameState.playerTeam.reduce((sum, c) => sum + c.bp, 0) / gameState.playerTeam.length;
            
            // Select characters with similar BP
            const similarBPCharacters = availableCharacters.filter(c => Math.abs(c.bp - playerAvgBP) <= 5);
            
            // If we don't have enough characters with similar BP, use any available characters
            const characterPool = similarBPCharacters.length >= 3 ? similarBPCharacters : availableCharacters;
            
            // Randomly select 3 characters
            while (gameState.aiTeam.length < 3 && characterPool.length > 0) {
                const randomIndex = Math.floor(Math.random() * characterPool.length);
                const character = characterPool[randomIndex];
                
                gameState.aiTeam.push({
                    ...character, 
                    currentBp: character.bp, 
                    isUltimateReady: false, 
                    ultimateCharge: 0,
                    cooldowns: {},
                    statusEffects: [],
                    defending: false,
                    damageDealt: 0,
                    healingDone: 0,
                    actionsPerformed: 0
                });
                characterPool.splice(randomIndex, 1);
            }
            
            // Select AI team leader
            gameState.aiLeaderId = gameState.aiTeam[Math.floor(Math.random() * 3)].id;
            
            // Select AI team strategy
            const strategies = ['offensive', 'defensive', 'balanced'];
            gameState.aiTeamStrategy = strategies[Math.floor(Math.random() * strategies.length)];
        }

        function setupBattleScreen() {
            // Reset battle state
            gameState.round = 1;
            gameState.turn = 1;
            gameState.battleLog = [];
            gameState.errorLog = [];
            gameState.activeCharacterIndex = 0;
            gameState.selectedAction = null;
            gameState.selectedSkill = null;
            gameState.battleStats = {
                roundsPlayed: 0,
                damageDealt: { player: 0, ai: 0 },
                healingDone: { player: 0, ai: 0 },
                criticalHits: { player: 0, ai: 0 },
                ultimatesUsed: { player: 0, ai: 0 },
                skillsUsed: { player: 0, ai: 0 },
                statusEffectsApplied: { player: 0, ai: 0 }
            };
            gameState.winner = null;
            
            // Update round counter
            document.getElementById('round-counter').textContent = `Round ${gameState.round}`;
            
            // Update battle style indicator
            document.getElementById('battle-style-indicator').textContent = `Style: ${battleStyles[gameState.battleStyle].name}`;
            
            // Update strategy displays
            document.getElementById('player-strategy').textContent = teamStrategies[gameState.teamStrategy].name;
            document.getElementById('ai-strategy').textContent = teamStrategies[gameState.aiTeamStrategy].name;
            
            // Update battle log
            const battleLog = document.getElementById('battle-log');
            battleLog.innerHTML = '';
            
            // Update error log
            const errorLog = document.getElementById('error-log');
            errorLog.innerHTML = '';
            errorLog.classList.add('hidden');
            
            // Add initial battle log entries
            addToBattleLog(`## Battle Begins!`);
            addToBattleLog(`Your Team (${teamStrategies[gameState.teamStrategy].name}): ${gameState.playerTeam.map(c => c.name).join(', ')}`);
            addToBattleLog(`Opponent Team (${teamStrategies[gameState.aiTeamStrategy].name}): ${gameState.aiTeam.map(c => c.name).join(', ')}`);
            
            // Log leaders
            const playerLeader = gameState.playerTeam.find(c => c.id === gameState.leaderId);
            const aiLeader = gameState.aiTeam.find(c => c.id === gameState.aiLeaderId);
            
            if (playerLeader) {
                addToBattleLog(`Your team leader: **${playerLeader.name}** (${playerLeader.leaderBonus})`);
            }
            
            if (aiLeader) {
                addToBattleLog(`Opponent team leader: **${aiLeader.name}** (${aiLeader.leaderBonus})`);
            }
            
            // Log battle style
            addToBattleLog(`Your battle style: **${battleStyles[gameState.battleStyle].name}** (${battleStyles[gameState.battleStyle].description})`);
            
            // Log active synergies
            const activePlayerSynergies = gameState.activeSynergies.filter(s => s.active);
            if (activePlayerSynergies.length > 0) {
                addToBattleLog(`Your team synergies: ${activePlayerSynergies.map(s => s.name).join(', ')}`);
            }
            
            // Render teams
            renderTeams();
            
            // Setup first turn
            setupNextTurn();
        }

        function renderTeams() {
            // Render player team
            const playerTeamContainer = document.getElementById('player-team');
            playerTeamContainer.innerHTML = '';
            
            gameState.playerTeam.forEach((character, index) => {
                const card = createBattleCharacterCard(character, index, 'player');
                playerTeamContainer.appendChild(card);
            });
            
            // Render AI team
            const aiTeamContainer = document.getElementById('ai-team');
            aiTeamContainer.innerHTML = '';
            
            gameState.aiTeam.forEach((character, index) => {
                const card = createBattleCharacterCard(character, index, 'ai');
                aiTeamContainer.appendChild(card);
            });
        }

        function createBattleCharacterCard(character, index, team) {
            const card = document.createElement('div');
            
            // Add base classes
            let cardClasses = `battle-character-card p-2 md:p-3 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border relative overflow-hidden ${team === 'player' ? 'player-character' : 'ai-character'} ${character.currentBp <= 0 ? 'opacity-50' : ''} card-3d`;
            
            // Add leader indicator and golden effects
            if ((team === 'player' && character.id === gameState.leaderId) || 
                (team === 'ai' && character.id === gameState.aiLeaderId)) {
                cardClasses += ' leader-card golden-glow';
            }
            
            // Highlight active character
            if (team === 'player' && index === gameState.activeCharacterIndex && character.currentBp > 0) {
                cardClasses += ' golden-neon-border';
            }
            
            card.className = cardClasses;
            card.dataset.characterIndex = index;
            card.dataset.team = team;
            
            // Calculate health percentage
            const healthPercentage = Math.max(0, Math.min(100, (character.currentBp / character.bp) * 100));
            const healthColorClass = healthPercentage > 66 ? 'bg-green-500' : healthPercentage > 33 ? 'bg-yellow-500' : 'bg-red-500';
            
            // Create status effect icons
            const statusEffectIcons = character.statusEffects?.map(effect => {
                const statusData = statusEffects[effect.type];
                return `<span class="status-effect ${effect.type}" title="${statusData.name}: ${statusData.description} (${effect.duration} turns)">${statusData.icon}</span>`;
            }).join('') || '';
            
            card.innerHTML = `
                <div class="card-3d-content">
                    <div class="flex justify-between items-start mb-1 md:mb-2">
                        <h3 class="font-medium text-sm md:text-base">${character.name}</h3>
                        <span class="px-2 py-0.5 text-xs rounded-full bg-primary bg-opacity-20">
                            BP: ${character.currentBp}/${character.bp}
                        </span>
                    </div>
                    <div class="h-2 bg-gray-200 dark:bg-gray-700 rounded-full mb-1 md:mb-2 overflow-hidden">
                        <div class="h-full ${healthColorClass} transition-all duration-500" style="width: ${healthPercentage}%"></div>
                    </div>
                    <div class="text-xs flex justify-between items-center">
                        <div>
                            <span class="font-medium">Ultimate:</span> 
                            <span class="${character.isUltimateReady ? 'golden-neon-text' : 'opacity-75'}">${Math.floor(character.ultimateCharge * 100)}%</span>
                        </div>
                        <div class="status-effects">
                            ${statusEffectIcons}
                            ${character.currentBp <= 0 ? '<span class="text-red-500 font-medium ml-1">Defeated</span>' : ''}
                            ${character.defending ? '<span class="text-blue-500 font-medium ml-1">🛡️</span>' : ''}
                        </div>
                    </div>
                </div>
            `;
            
            return card;
        }

        function setupNextTurn() {
            // Find next active character
            let foundActiveCharacter = false;
            const startIndex = gameState.activeCharacterIndex;
            
            // Loop through player team to find next active character
            for (let i = 0; i < gameState.playerTeam.length; i++) {
                const checkIndex = (startIndex + i) % gameState.playerTeam.length;
                if (gameState.playerTeam[checkIndex].currentBp > 0) {
                    gameState.activeCharacterIndex = checkIndex;
                    foundActiveCharacter = true;
                    break;
                }
            }
            
            // If no active character found, check if the battle is over
            if (!foundActiveCharacter) {
                // All player characters are defeated
                endBattle('ai');
                return;
            }
            
            // Check if AI team is defeated
            if (gameState.aiTeam.every(c => c.currentBp <= 0)) {
                // All AI characters are defeated
                endBattle('player');
                return;
            }
            
            // Apply status effects for start of turn
            processStartOfTurnEffects();
            
            // Update active character info
            const activeCharacter = gameState.playerTeam[gameState.activeCharacterIndex];
            
            // Generate status effect text
            let statusText = '';
            if (activeCharacter.statusEffects?.length > 0) {
                statusText = activeCharacter.statusEffects.map(effect => {
                    const statusData = statusEffects[effect.type];
                    return `${statusData.name} (${effect.duration}t)`;
                }).join(', ');
                statusText = `<br>Status: <span class="text-yellow-500">${statusText}</span>`;
            }
            
            document.getElementById('active-character-info').innerHTML = `
                <p>Active Character: <strong class="${activeCharacter.isUltimateReady ? 'golden-neon-text' : ''}">${activeCharacter.name}</strong> ${activeCharacter.isUltimateReady ? '<span class="golden-neon-text ml-1">(Ultimate Ready!)</span>' : ''}</p>
                <p>BP: ${activeCharacter.currentBp}/${activeCharacter.bp}${statusText}</p>
            `;
            
            // Update special ability description
            document.querySelector('.special-desc').textContent = activeCharacter.isUltimateReady 
                ? `Use ${activeCharacter.ultimate}` 
                : `Charge ultimate`;
            
            // Add golden glow to ultimate button if ready
            const ultimateBtn = document.querySelector('.ultimate-btn');
            if (activeCharacter.isUltimateReady) {
                ultimateBtn.classList.add('golden-glow');
            } else {
                ultimateBtn.classList.remove('golden-glow');
            }
            
            // Update skill list
            document.getElementById('skill-list').textContent = `${activeCharacter.skills.length} skills available`;
            
            // Check if character can't act due to status effects
            if (hasStatusEffect(activeCharacter, 'stunned')) {
                addToBattleLog(`*${activeCharacter.name}* is stunned and cannot act this turn!`);
                // Auto-advance after a delay
                document.getElementById('next-turn').disabled = true;
                setTimeout(() => {
                    removeStatusEffect(activeCharacter, 'stunned');
                    gameState.activeCharacterIndex = (gameState.activeCharacterIndex + 1) % gameState.playerTeam.length;
                    setupNextTurn();
                    document.getElementById('next-turn').disabled = false;
                }, 1500);
                return;
            }
            
            // Update character styles
            renderTeams();
            
            // Show action selection
            showActionSelection();
        }

        function processStartOfTurnEffects() {
            const activeCharacter = gameState.playerTeam[gameState.activeCharacterIndex];
            if (!activeCharacter || activeCharacter.currentBp <= 0) return;
            
            // Process status effects
            if (activeCharacter.statusEffects?.length > 0) {
                activeCharacter.statusEffects.forEach(effect => {
                    if (effect.type === 'poisoned' || effect.type === 'burned') {
                        const damage = Math.floor(activeCharacter.bp * 0.05);
                        activeCharacter.currentBp = Math.max(0, activeCharacter.currentBp - damage);
                        addToBattleLog(`*${activeCharacter.name}* takes ${damage} damage from ${statusEffects[effect.type].name}!`);
                    } else if (effect.type === 'regenerating') {
                        const healing = Math.floor(activeCharacter.bp * 0.05);
                        activeCharacter.currentBp = Math.min(activeCharacter.bp, activeCharacter.currentBp + healing);
                        activeCharacter.healingDone += healing;
                        gameState.battleStats.healingDone.player += healing;
                        addToBattleLog(`*${activeCharacter.name}* recovers ${healing} BP from ${statusEffects[effect.type].name}!`);
                    }
                });
            }
            
            // Decrement cooldowns
            for (const skill in activeCharacter.cooldowns) {
                if (activeCharacter.cooldowns[skill] > 0) {
                    activeCharacter.cooldowns[skill]--;
                }
            }
        }

        function hasStatusEffect(character, effectType) {
            return character.statusEffects?.some(effect => effect.type === effectType) || false;
        }

        function addStatusEffect(character, effectType, duration) {
            if (!character.statusEffects) character.statusEffects = [];
            
            // If the character already has this effect, refresh the duration
            const existingEffect = character.statusEffects.find(effect => effect.type === effectType);
            if (existingEffect) {
                existingEffect.duration = Math.max(existingEffect.duration, duration);
            } else {
                character.statusEffects.push({
                    type: effectType,
                    duration: duration
                });
            }
        }

        function removeStatusEffect(character, effectType) {
            if (!character.statusEffects) return;
            character.statusEffects = character.statusEffects.filter(effect => effect.type !== effectType);
        }

        function decrementStatusEffects(character) {
            if (!character.statusEffects || character.statusEffects.length === 0) return;
            
            character.statusEffects.forEach(effect => {
                effect.duration--;
            });
            
            // Remove expired effects
            character.statusEffects = character.statusEffects.filter(effect => effect.duration > 0);
        }

        function showActionSelection() {
            document.getElementById('action-selection').classList.remove('hidden');
            document.getElementById('target-selection').classList.add('hidden');
            document.getElementById('skill-selection').classList.add('hidden');
        }

        function selectAction(action) {
            gameState.selectedAction = action;
            
            // Play sound
            playSound('attack');
            
            if (action === 'skill') {
                showSkillSelection();
                return;
            }
            
            // If the active character's ultimate is ready and they chose "special", use ultimate
            const activeCharacter = gameState.playerTeam[gameState.activeCharacterIndex];
            if (action === 'special' && activeCharacter.isUltimateReady) {
                gameState.selectedAction = 'ultimate';
                playSound('ultimate');
            }
            
            // If attack or ultimate, show target selection
            if (action === 'attack' || action === 'ultimate') {
                showTargetSelection();
            } else {
                // For defend or special (charging ultimate), no target needed
                processTurn();
            }
        }

        function showSkillSelection() {
            const activeCharacter = gameState.playerTeam[gameState.activeCharacterIndex];
            const skillButtons = document.getElementById('skill-buttons');
            skillButtons.innerHTML = '';
            
            // Create a button for each skill
            activeCharacter.skills.forEach((skill, index) => {
                const cooldown = activeCharacter.cooldowns[index] || 0;
                const isOnCooldown = cooldown > 0;
                
                const button = document.createElement('button');
                button.className = `p-2 md:p-3 text-left ${isOnCooldown ? 'opacity-50 cursor-not-allowed' : 'bg-primary bg-opacity-20 hover:bg-opacity-40 cursor-pointer card-3d'} rounded-md transition-all`;
                button.disabled = isOnCooldown;
                
                button.innerHTML = `
                    <div class="card-3d-content">
                        <span class="font-medium text-sm">${skill.name}</span>
                        <div class="flex justify-between">
                            <span class="block text-xs opacity-75">${skill.description}</span>
                            ${isOnCooldown ? `<span class="text-xs text-red-500">Cooldown: ${cooldown}t</span>` : ''}
                        </div>
                    </div>
                `;
                
                if (!isOnCooldown) {
                    button.addEventListener('click', () => {
                        gameState.selectedAction = 'skill';
                        gameState.selectedSkill = index;
                        playSound('attack');
                        
                        // For offensive or control skills, show target selection
                        if (skill.type === 'offensive' || skill.type === 'control' || skill.type === 'lifesteal') {
                            showTargetSelection();
                        } else {
                            // For defensive, buff, healing skills, no target needed or target is self/allies
                            processTurn();
                        }
                    });
                }
                
                skillButtons.appendChild(button);
            });
            
            // Hide action selection, show skill selection
            document.getElementById('action-selection').classList.add('hidden');
            document.getElementById('skill-selection').classList.remove('hidden');
        }

        function showTargetSelection() {
            const targetButtons = document.getElementById('target-buttons');
            targetButtons.innerHTML = '';
            
            // For most actions, target enemies
            let targetTeam = gameState.aiTeam;
            
            // For some skill types, target allies
            const activeCharacter = gameState.playerTeam[gameState.activeCharacterIndex];
            if (gameState.selectedAction === 'skill') {
                const skill = activeCharacter.skills[gameState.selectedSkill];
                if (skill.type === 'defensive' || skill.type === 'buff' || skill.type === 'healing' || skill.type === 'support') {
                    targetTeam = gameState.playerTeam;
                }
            }
            
            // Create a button for each potential target
            targetTeam.forEach((character, index) => {
                if (character.currentBp <= 0) return; // Skip defeated characters
                
                const button = document.createElement('button');
                button.className = 'px-3 md:px-4 py-2 bg-primary bg-opacity-20 hover:bg-opacity-40 rounded-md transition-all card-3d';
                button.dataset.targetIndex = index;
                button.dataset.targetTeam = targetTeam === gameState.aiTeam ? 'ai' : 'player';
                
                // Calculate health percentage
                const healthPercentage = Math.max(0, Math.min(100, (character.currentBp / character.bp) * 100));
                
                button.innerHTML = `
                    <div class="card-3d-content">
                        <span class="font-medium text-sm">${character.name}</span>
                        <div class="flex items-center justify-between text-xs">
                            <span class="opacity-75">BP: ${character.currentBp}/${character.bp}</span>
                            <div class="w-16 h-1 bg-gray-200 dark:bg-gray-700 rounded-full overflow-hidden ml-1">
                                <div class="h-full ${healthPercentage > 66 ? 'bg-green-500' : healthPercentage > 33 ? 'bg-yellow-500' : 'bg-red-500'}" style="width: ${healthPercentage}%"></div>
                            </div>
                        </div>
                    </div>
                `;
                
                button.addEventListener('click', () => {
                    gameState.targetIndex = index;
                    gameState.targetTeam = button.dataset.targetTeam;
                    playSound('attack');
                    processTurn();
                });
                
                targetButtons.appendChild(button);
            });
            
            // If no targets available (all defeated), auto-process the turn
            if (targetButtons.children.length === 0) {
                addToBattleLog(`No valid targets available!`);
                processTurn();
                return;
            }
            
            // Hide action selection, show target selection
            document.getElementById('action-selection').classList.add('hidden');
            document.getElementById('skill-selection').classList.add('hidden');
            document.getElementById('target-selection').classList.remove('hidden');
        }

        function processTurn() {
            // If no action selected, do nothing
            if (!gameState.selectedAction) return;
            
            // Process player action
            processPlayerAction();
            
            // Check if battle is over
            if (gameState.aiTeam.every(c => c.currentBp <= 0)) {
                endBattle('player');
                return;
            }
            
            // Process AI action after a short delay
            document.getElementById('next-turn').disabled = true;
            setTimeout(() => {
                processAIAction();
                
                // Check if battle is over
                if (gameState.playerTeam.every(c => c.currentBp <= 0)) {
                    endBattle('ai');
                    return;
                }
                
                // Update both teams (status effects might have changed things)
                renderTeams();
                
                // Move to next character
                gameState.activeCharacterIndex = (gameState.activeCharacterIndex + 1) % gameState.playerTeam.length;
                
                // Check if we've completed a round
                if (gameState.activeCharacterIndex === 0) {
                    gameState.round++;
                    gameState.battleStats.roundsPlayed++;
                    document.getElementById('round-counter').textContent = `Round ${gameState.round}`;
                    addToBattleLog(`## Round ${gameState.round} begins`);
                }
                
                // Decrease defending status from all characters
                gameState.playerTeam.forEach(c => {
                    c.defending = false;
                });
                
                gameState.aiTeam.forEach(c => {
                    c.defending = false;
                });
                
                // Setup next turn
                setupNextTurn();
                document.getElementById('next-turn').disabled = false;
            }, 1200);
        }

        function processPlayerAction() {
            const activeCharacter = gameState.playerTeam[gameState.activeCharacterIndex];
            
            // Apply battle style effects
            const battleStyle = battleStyles[gameState.battleStyle];
            
            // Apply team strategy effects
            const strategy = teamStrategies[gameState.teamStrategy];
            
            if (gameState.selectedAction === 'attack') {
                const targetCharacter = gameState.aiTeam[gameState.targetIndex];
                
                // Play sound
                playSound('attack');
                
                // Calculate base damage with battle style modifiers
                let baseDamage = Math.floor(activeCharacter.bp * 0.1) + Math.floor(Math.random() * 6);
                baseDamage = Math.floor(baseDamage * battleStyle.effects.damageMultiplier);
                baseDamage = Math.floor(baseDamage * strategy.effects.damageMultiplier);
                
                // Apply character-specific combat style bonus
                const combatStyleBonus = activeCharacter.combatStyle[battleStyle.animation.split('-')[0]];
                baseDamage = Math.floor(baseDamage * (1 + (combatStyleBonus * 0.2)));
                
                // Check for critical hit
                const criticalChance = 0.2 + (strategy.effects.criticalHitChance || 0);
                const isCritical = Math.random() < criticalChance;
                let damage = isCritical ? Math.floor(baseDamage * 1.5) : baseDamage;
                
                // Apply leader bonus if applicable
                if (gameState.leaderId === activeCharacter.id) {
                    damage = Math.floor(damage * 1.1); // 10% damage boost for leader
                }
                
                // Apply active synergies
                gameState.activeSynergies.forEach(synergy => {
                    if (synergy.active && synergy.effect.damageMultiplier) {
                        damage = Math.floor(damage * synergy.effect.damageMultiplier);
                    }
                });
                
                // Apply defensive reductions from target
                if (targetCharacter.defending) {
                    damage = Math.floor(damage * 0.6);
                }
                
                // Apply status effect reductions
                if (hasStatusEffect(activeCharacter, 'frozen')) {
                    damage = Math.floor(damage * 0.7);
                }
                
                if (hasStatusEffect(targetCharacter, 'protected')) {
                    damage = Math.floor(damage * 0.8);
                }
                
                if (hasStatusEffect(targetCharacter, 'vulnerable')) {
                    damage = Math.floor(damage * 1.2);
                }
                
                // Apply damage
                targetCharacter.currentBp = Math.max(0, targetCharacter.currentBp - damage);
                
                // Update stats
                activeCharacter.damageDealt += damage;
                gameState.battleStats.damageDealt.player += damage;
                if (isCritical) gameState.battleStats.criticalHits.player++;
                activeCharacter.actionsPerformed++;
                
                // Log action
                if (battleStyle.animation === 'aerial') {
                    addToBattleLog(`*${activeCharacter.name}* performs an aerial attack on ${targetCharacter.name}, striking from above for **${damage} damage**${isCritical ? ' (Critical Hit!)' : ''}!`);
                } else if (battleStyle.animation === 'ground') {
                    addToBattleLog(`*${activeCharacter.name}* executes a powerful ground assault on ${targetCharacter.name} for **${damage} damage**${isCritical ? ' (Critical Hit!)' : ''}!`);
                } else if (battleStyle.animation === 'coordinate') {
                    addToBattleLog(`*${activeCharacter.name}* coordinates a tactical strike against ${targetCharacter.name} for **${damage} damage**${isCritical ? ' (Critical Hit!)' : ''}!`);
                } else if (battleStyle.animation === 'hold-ground') {
                    addToBattleLog(`*${activeCharacter.name}* stands firm and strikes ${targetCharacter.name} for **${damage} damage**${isCritical ? ' (Critical Hit!)' : ''}!`);
                } else if (battleStyle.animation === 'play-by-ear') {
                    addToBattleLog(`*${activeCharacter.name}* adapts to the situation, attacking ${targetCharacter.name} for **${damage} damage**${isCritical ? ' (Critical Hit!)' : ''}!`);
                } else {
                    addToBattleLog(`*${activeCharacter.name}* attacks ${targetCharacter.name} for **${damage} damage**${isCritical ? ' (Critical Hit!)' : ''}!`);
                }
                
                // Chance to apply status effect based on character and synergies
                const statusEffectChance = 0.15 + (battleStyle.effects.statusEffectChance || 0);
                if (Math.random() < statusEffectChance) {
                    const possibleEffects = ['stunned', 'burned', 'vulnerable'];
                    const effect = possibleEffects[Math.floor(Math.random() * possibleEffects.length)];
                    addStatusEffect(targetCharacter, effect, effect === 'stunned' ? 1 : 2);
                    gameState.battleStats.statusEffectsApplied.player++;
                    addToBattleLog(`${targetCharacter.name} is affected by **${statusEffects[effect].name}**!`);
                }
                
                // Charge ultimate (more charge when dealing damage)
                if (!activeCharacter.isUltimateReady) {
                    const chargeAmount = 0.15 + (damage / activeCharacter.bp * 0.1);
                    activeCharacter.ultimateCharge = Math.min(1, activeCharacter.ultimateCharge + chargeAmount);
                    
                    if (activeCharacter.ultimateCharge >= 1) {
                        activeCharacter.isUltimateReady = true;
                        addToBattleLog(`*${activeCharacter.name}'s* ultimate ability is now ready!`);
                    }
                }
                
                // Animate attack based on battle style
                animateAction('player', gameState.activeCharacterIndex, 'ai', gameState.targetIndex, battleStyle.animation);
                
            } else if (gameState.selectedAction === 'defend') {
                // Apply defense buff
                activeCharacter.defending = true;
                
                // Additional benefits based on battle style
                if (battleStyle.animation === 'hold-ground') {
                    addStatusEffect(activeCharacter, 'protected', 2);
                    addToBattleLog(`*${activeCharacter.name}* takes a powerful defensive stance, significantly reducing incoming damage!`);
                } else {
                    addToBattleLog(`*${activeCharacter.name}* takes a defensive stance, reducing incoming damage!`);
                }
                
                // Charge ultimate (less charge when defending)
                if (!activeCharacter.isUltimateReady) {
                    const chargeAmount = 0.1;
                    activeCharacter.ultimateCharge = Math.min(1, activeCharacter.ultimateCharge + chargeAmount);
                    
                    if (activeCharacter.ultimateCharge >= 1) {
                        activeCharacter.isUltimateReady = true;
                        addToBattleLog(`*${activeCharacter.name}'s* ultimate ability is now ready!`);
                    }
                }
                
                activeCharacter.actionsPerformed++;
                
                // Animate defend
                animateAction('player', gameState.activeCharacterIndex, null, null, 'defend');
                
            } else if (gameState.selectedAction === 'special') {
                // Charge ultimate to full
                activeCharacter.ultimateCharge = 1;
                activeCharacter.isUltimateReady = true;
                
                // Play sound
                playSound('attack');
                
                // Apply additional benefits based on battle style
                if (battleStyle.animation === 'play-by-ear') {
                    // Adaptive style provides random buffs
                    const possibleBuffs = ['strengthened', 'protected', 'regenerating'];
                    const buff = possibleBuffs[Math.floor(Math.random() * possibleBuffs.length)];
                    addStatusEffect(activeCharacter, buff, 2);
                    addToBattleLog(`*${activeCharacter.name}* focuses energy, preparing their ultimate ability and gaining **${statusEffects[buff].name}**!`);
                } else {
                    addToBattleLog(`*${activeCharacter.name}* focuses energy, preparing their ultimate ability!`);
                }
                
                activeCharacter.actionsPerformed++;
                
                // Animate special
                animateAction('player', gameState.activeCharacterIndex, null, null, 'hold-ground');
                
            } else if (gameState.selectedAction === 'ultimate') {
                const targetCharacter = gameState.aiTeam[gameState.targetIndex];
                
                // Play ultimate sound
                playSound('ultimate');
                
                // Calculate ultimate damage with modifiers
                let ultimateDamage = Math.floor(activeCharacter.bp * 0.25) + Math.floor(Math.random() * 10);
                
                // Apply synergies
                gameState.activeSynergies.forEach(synergy => {
                    if (synergy.active && synergy.effect.ultimateDamageBonus) {
                        ultimateDamage = Math.floor(ultimateDamage * synergy.effect.ultimateDamageBonus);
                    }
                });
                
                // Apply battle style effects
                if (battleStyle.animation === 'aerial' || battleStyle.animation === 'ground') {
                    ultimateDamage = Math.floor(ultimateDamage * 1.15);
                }
                
                // Apply defensive reductions from target
                if (targetCharacter.defending) {
                    ultimateDamage = Math.floor(ultimateDamage * 0.8);
                }
                
                // Apply damage
                targetCharacter.currentBp = Math.max(0, targetCharacter.currentBp - ultimateDamage);
                
                // Update stats
                activeCharacter.damageDealt += ultimateDamage;
                gameState.battleStats.damageDealt.player += ultimateDamage;
                gameState.battleStats.ultimatesUsed.player++;
                activeCharacter.actionsPerformed++;
                
                // Apply ultimate-specific effects based on character
                let additionalEffect = '';
                
                if (activeCharacter.name === 'Doctor Strange') {
                    // Restore 30% BP to all allies and reset cooldowns
                    gameState.playerTeam.forEach(ally => {
                        if (ally.currentBp > 0) {
                            const healing = Math.floor(ally.bp * 0.3);
                            ally.currentBp = Math.min(ally.bp, ally.currentBp + healing);
                            gameState.battleStats.healingDone.player += healing;
                            ally.cooldowns = {};
                        }
                    });
                    additionalEffect = `, restoring health to allies and resetting all cooldowns`;
                } else if (activeCharacter.name === 'Scarlet Witch') {
                    // Deal damage to all enemies
                    gameState.aiTeam.forEach(enemy => {
                        if (enemy.currentBp > 0 && enemy.id !== targetCharacter.id) {
                            const splashDamage = Math.floor(ultimateDamage * 0.5);
                            enemy.currentBp = Math.max(0, enemy.currentBp - splashDamage);
                            activeCharacter.damageDealt += splashDamage;
                            gameState.battleStats.damageDealt.player += splashDamage;
                            
                            // Apply 'Corrupted' status
                            addStatusEffect(enemy, 'poisoned', 3);
                        }
                    });
                    additionalEffect = `, damaging all enemies and applying Corrupted status`;
                } else if (activeCharacter.name === 'Thanos') {
                    // 50% chance to instantly defeat enemy
                    if (Math.random() < 0.5) {
                        targetCharacter.currentBp = 0;
                        additionalEffect = `, instantly defeating the target!`;
                    }
                } else if (activeCharacter.ultimateEffect && activeCharacter.ultimateEffect.includes('all enemies')) {
                    // Apply area effect to all enemies
                    gameState.aiTeam.forEach(enemy => {
                        if (enemy.currentBp > 0 && enemy.id !== targetCharacter.id) {
                            const splashDamage = Math.floor(ultimateDamage * 0.4);
                            enemy.currentBp = Math.max(0, enemy.currentBp - splashDamage);
                            activeCharacter.damageDealt += splashDamage;
                            gameState.battleStats.damageDealt.player += splashDamage;
                        }
                    });
                    additionalEffect = `, striking all enemies`;
                }
                
                // Log action
                addToBattleLog(`*${activeCharacter.name}* unleashes their ultimate ability **${activeCharacter.ultimate}** on ${targetCharacter.name} for **${ultimateDamage} damage**${additionalEffect}!`);
                
                // Reset ultimate
                activeCharacter.isUltimateReady = false;
                activeCharacter.ultimateCharge = 0;
                
                // Animate ultimate
                animateAction('player', gameState.activeCharacterIndex, 'ai', gameState.targetIndex, 'ultimate');
                
            } else if (gameState.selectedAction === 'skill') {
                const skill = activeCharacter.skills[gameState.selectedSkill];
                
                // Play sound
                playSound('attack');
                
                // Set cooldown for this skill
                activeCharacter.cooldowns[gameState.selectedSkill] = skill.cooldown;
                
                // Process skill based on type
                if (skill.type === 'offensive' || skill.type === 'control') {
                    const targetCharacter = gameState.aiTeam[gameState.targetIndex];
                    
                    // Calculate skill damage with modifiers
                    let skillDamage = 0;
                    let controlEffect = null;
                    
                    // Extract damage from skill description (e.g., "dealing 15 damage")
                    const damageMatch = skill.description.match(/dealing (\d+) damage/);
                    if (damageMatch) {
                        skillDamage = parseInt(damageMatch[1]);
                        
                        // Apply modifiers
                        skillDamage = Math.floor(skillDamage * strategy.effects.damageMultiplier);
                        
                        // Apply combat style bonus for skill
                        const combatStyleBonus = activeCharacter.combatStyle[battleStyle.animation.split('-')[0]];
                        skillDamage = Math.floor(skillDamage * (1 + (combatStyleBonus * 0.1)));
                    }
                    
                    // Check for status effects in description (e.g., "20% stun chance")
                    const statusMatch = skill.description.match(/(\d+)% (\w+) chance/);
                    if (statusMatch) {
                        const chance = parseInt(statusMatch[1]) / 100;
                        const statusType = statusMatch[2];
                        
                        // Map status names to actual effect types
                        const statusMap = {
                            'stun': 'stunned',
                            'burn': 'burned',
                            'poison': 'poisoned',
                            'freeze': 'frozen'
                        };
                        
                        if (Math.random() < chance) {
                            controlEffect = statusMap[statusType] || statusType;
                        }
                    }
                    
                    // Apply damage if applicable
                    if (skillDamage > 0) {
                        // Apply defensive reductions
                        if (targetCharacter.defending) {
                            skillDamage = Math.floor(skillDamage * 0.7);
                        }
                        
                        targetCharacter.currentBp = Math.max(0, targetCharacter.currentBp - skillDamage);
                        activeCharacter.damageDealt += skillDamage;
                        gameState.battleStats.damageDealt.player += skillDamage;
                    }
                    
                    // Apply control effect if applicable
                    if (controlEffect) {
                        addStatusEffect(targetCharacter, controlEffect, controlEffect === 'stunned' ? 1 : 2);
                        gameState.battleStats.statusEffectsApplied.player++;
                    }
                    
                    // Log action
                    addToBattleLog(`*${activeCharacter.name}* uses **${skill.name}** on ${targetCharacter.name}${skillDamage > 0 ? ` for **${skillDamage} damage**` : ''}${controlEffect ? ` and applies **${statusEffects[controlEffect].name}**` : ''}!`);
                    
                    // Chance to charge ultimate
                    if (!activeCharacter.isUltimateReady) {
                        const chargeAmount = 0.15;
                        activeCharacter.ultimateCharge = Math.min(1, activeCharacter.ultimateCharge + chargeAmount);
                        
                        if (activeCharacter.ultimateCharge >= 1) {
                            activeCharacter.isUltimateReady = true;
                            addToBattleLog(`*${activeCharacter.name}'s* ultimate ability is now ready!`);
                        }
                    }
                    
                    // Animate skill based on type
                    const animationStyle = skill.type === 'control' ? 'coordinate' : battleStyle.animation;
                    animateAction('player', gameState.activeCharacterIndex, 'ai', gameState.targetIndex, animationStyle);
                    
                } else if (skill.type === 'defensive' || skill.type === 'buff') {
                    // Apply to self or target ally
                    const targetCharacter = gameState.targetTeam === 'player' && gameState.targetIndex !== undefined 
                                          ? gameState.playerTeam[gameState.targetIndex] 
                                          : activeCharacter;
                    
                    // Apply buff based on skill description
                    if (skill.description.includes('reducing damage')) {
                        targetCharacter.defending = true;
                        addStatusEffect(targetCharacter, 'protected', 2);
                    } else if (skill.description.includes('increasing damage')) {
                        addStatusEffect(targetCharacter, 'strengthened', 2);
                    } else if (skill.description.includes('heal')) {
                        const healMatch = skill.description.match(/heal (?:for )?(\d+)/);
                        if (healMatch) {
                            const healAmount = parseInt(healMatch[1]);
                            targetCharacter.currentBp = Math.min(targetCharacter.bp, targetCharacter.currentBp + healAmount);
                            activeCharacter.healingDone += healAmount;
                            gameState.battleStats.healingDone.player += healAmount;
                        }
                    }
                    
                    // Log action
                    if (targetCharacter.id === activeCharacter.id) {
                        addToBattleLog(`*${activeCharacter.name}* uses **${skill.name}**, ${skill.description.toLowerCase().replace(/dealing|for/g, '')}!`);
                    } else {
                        addToBattleLog(`*${activeCharacter.name}* uses **${skill.name}** on ${targetCharacter.name}, ${skill.description.toLowerCase().replace(/dealing|for/g, '')}!`);
                    }
                    
                    // Animate defensive skill
                    animateAction('player', gameState.activeCharacterIndex, 
                                 targetCharacter.id !== activeCharacter.id ? 'player' : null, 
                                 targetCharacter.id !== activeCharacter.id ? gameState.targetIndex : null, 
                                 'hold-ground');
                    
                } else if (skill.type === 'lifesteal') {
                    const targetCharacter = gameState.aiTeam[gameState.targetIndex];
                    
                    // Extract damage from skill description
                    const damageMatch = skill.description.match(/(\d+) damage/);
                    if (damageMatch) {
                        let skillDamage = parseInt(damageMatch[1]);
                        
                        // Apply modifiers
                        skillDamage = Math.floor(skillDamage * strategy.effects.damageMultiplier);
                        
                        // Apply defensive reductions
                        if (targetCharacter.defending) {
                            skillDamage = Math.floor(skillDamage * 0.7);
                        }
                        
                        // Apply damage
                        targetCharacter.currentBp = Math.max(0, targetCharacter.currentBp - skillDamage);
                        activeCharacter.damageDealt += skillDamage;
                        gameState.battleStats.damageDealt.player += skillDamage;
                        
                        // Calculate healing (from description or default to 50%)
                        const healPercentMatch = skill.description.match(/heal for (\d+)% of damage/);
                        const healPercent = healPercentMatch ? parseInt(healPercentMatch[1]) / 100 : 0.5;
                        
                        const healAmount = Math.floor(skillDamage * healPercent);
                        activeCharacter.currentBp = Math.min(activeCharacter.bp, activeCharacter.currentBp + healAmount);
                        activeCharacter.healingDone += healAmount;
                        gameState.battleStats.healingDone.player += healAmount;
                        
                        // Log action
                        addToBattleLog(`*${activeCharacter.name}* uses **${skill.name}** on ${targetCharacter.name} for **${skillDamage} damage** and heals for **${healAmount} BP**!`);
                    }
                    
                    // Animate lifesteal
                    animateAction('player', gameState.activeCharacterIndex, 'ai', gameState.targetIndex, 'ground');
                }
                
                gameState.battleStats.skillsUsed.player++;
                activeCharacter.actionsPerformed++;
            }
            
            // Reset action and target
            gameState.selectedAction = null;
            gameState.selectedSkill = null;
            gameState.targetIndex = null;
            gameState.targetTeam = null;
            
            // Update team display
            renderTeams();
        }

        function processAIAction() {
            // Find a living AI character
            const livingAI = gameState.aiTeam.filter(c => c.currentBp > 0);
            if (livingAI.length === 0) return;
            
            const activeAIIndex = gameState.aiTeam.findIndex(c => c.id === livingAI[Math.floor(Math.random() * livingAI.length)].id);
            const activeAI = gameState.aiTeam[activeAIIndex];
            
            // Skip turn if stunned
            if (hasStatusEffect(activeAI, 'stunned')) {
                addToBattleLog(`*${activeAI.name}* is stunned and cannot act this turn!`);
                removeStatusEffect(activeAI, 'stunned');
                return;
            }
            
            // Find a living player character to target
            const livingPlayers = gameState.playerTeam.filter(c => c.currentBp > 0);
            if (livingPlayers.length === 0) return;
            
            // Apply strategic AI decision making based on team strategy
            const aiStrategy = teamStrategies[gameState.aiTeamStrategy];
            
            // Create a weighted decision making process
            let actions = [
                { name: 'attack', weight: 50 },
                { name: 'defend', weight: 15 },
                { name: 'special', weight: 15 },
                { name: 'skill', weight: 20 }
            ];
            
            // Adjust weights based on strategy
            if (gameState.aiTeamStrategy === 'offensive') {
                actions[0].weight += 15; // Attack more
                actions[1].weight -= 5;  // Defend less
            } else if (gameState.aiTeamStrategy === 'defensive') {
                actions[0].weight -= 10; // Attack less
                actions[1].weight += 15; // Defend more
                actions[2].weight += 5;  // Special more
            }
            
            // Adjust weights based on character state
            if (activeAI.isUltimateReady) {
                actions[2].weight += 30; // Use ultimate when ready
            }
            
            if (activeAI.currentBp < activeAI.bp * 0.3) {
                actions[1].weight += 20; // Defend more when low health
                actions[0].weight -= 15; // Attack less when low health
            }
            
            // Check if any skills are off cooldown
            const hasAvailableSkill = activeAI.skills.some((_, index) => 
                !activeAI.cooldowns[index] || activeAI.cooldowns[index] <= 0
            );
            
            if (!hasAvailableSkill) {
                actions[3].weight = 0; // Can't use skills if all on cooldown
            }
            
            // Select action based on weights
            const totalWeight = actions.reduce((sum, action) => sum + action.weight, 0);
            let rand = Math.random() * totalWeight;
            let selectedAction = actions[0].name;
            
            for (const action of actions) {
                if (rand < action.weight) {
                    selectedAction = action.name;
                    break;
                }
                rand -= action.weight;
            }
            
            // Get target based on action type and strategy
            let targetPlayerIndex;
            
            if (gameState.aiTeamStrategy === 'offensive') {
                // Target the weakest player character
                const weakestPlayer = livingPlayers.reduce(
                    (weakest, current) => current.currentBp < weakest.currentBp ? current : weakest,
                    livingPlayers[0]
                );
                targetPlayerIndex = gameState.playerTeam.findIndex(c => c.id === weakestPlayer.id);
            } else if (gameState.aiTeamStrategy === 'defensive') {
                // Target the strongest player character
                const strongestPlayer = livingPlayers.reduce(
                    (strongest, current) => current.currentBp > strongest.currentBp ? current : strongest,
                    livingPlayers[0]
                );
                targetPlayerIndex = gameState.playerTeam.findIndex(c => c.id === strongestPlayer.id);
            } else {
                // Balanced strategy or fallback - random target
                targetPlayerIndex = gameState.playerTeam.findIndex(c => c.id === livingPlayers[Math.floor(Math.random() * livingPlayers.length)].id);
            }
            
            const targetPlayer = gameState.playerTeam[targetPlayerIndex];
            
            // Execute selected action
            if (selectedAction === 'attack') {
                // Regular attack
                const baseDamage = Math.floor(activeAI.bp * 0.1) + Math.floor(Math.random() * 5);
                const isCritical = Math.random() < (0.2 + (aiStrategy.effects.criticalHitChance || 0));
                const damage = isCritical ? Math.floor(baseDamage * 1.5) : baseDamage;
                
                // Play sound
                playSound('attack');
                
                // Apply leader bonus if applicable
                let finalDamage = gameState.aiLeaderId === activeAI.id ? Math.floor(damage * 1.1) : damage;
                
                // Apply damage with defense reduction if applicable
                const defenseMultiplier = targetPlayer.defending ? 0.6 : 1;
                finalDamage = Math.floor(finalDamage * defenseMultiplier);
                
                // Apply status effect reductions
                if (hasStatusEffect(activeAI, 'frozen')) {
                    finalDamage = Math.floor(finalDamage * 0.7);
                }
                
                if (hasStatusEffect(targetPlayer, 'protected')) {
                    finalDamage = Math.floor(finalDamage * 0.8);
                }
                
                if (hasStatusEffect(activeAI, 'strengthened')) {
                    finalDamage = Math.floor(finalDamage * 1.2);
                }
                
                if (hasStatusEffect(targetPlayer, 'vulnerable')) {
                    finalDamage = Math.floor(finalDamage * 1.2);
                }
                
                targetPlayer.currentBp = Math.max(0, targetPlayer.currentBp - finalDamage);
                
                // Update stats
                activeAI.damageDealt += finalDamage;
                gameState.battleStats.damageDealt.ai += finalDamage;
                if (isCritical) gameState.battleStats.criticalHits.ai++;
                activeAI.actionsPerformed++;
                
                // Log action
                let actionText = `*${activeAI.name}* attacks ${targetPlayer.name} for **${finalDamage} damage**${isCritical ? ' (Critical Hit!)' : ''}!`;
                if (targetPlayer.defending) {
                    actionText += ` ${targetPlayer.name}'s defensive stance reduced the damage!`;
                }
                addToBattleLog(actionText);
                
                // Chance to apply status effect
                if (Math.random() < 0.15) {
                    const possibleEffects = ['stunned', 'burned', 'vulnerable'];
                    const effect = possibleEffects[Math.floor(Math.random() * possibleEffects.length)];
                    addStatusEffect(targetPlayer, effect, effect === 'stunned' ? 1 : 2);
                    gameState.battleStats.statusEffectsApplied.ai++;
                    addToBattleLog(`${targetPlayer.name} is affected by **${statusEffects[effect].name}**!`);
                }
                
                // Charge ultimate
                if (!activeAI.isUltimateReady) {
                    const chargeAmount = 0.15 + (finalDamage / activeAI.bp * 0.1);
                    activeAI.ultimateCharge = Math.min(1, activeAI.ultimateCharge + chargeAmount);
                    
                    if (activeAI.ultimateCharge >= 1) {
                        activeAI.isUltimateReady = true;
                        addToBattleLog(`*${activeAI.name}'s* ultimate ability is now ready!`);
                    }
                }
                
                // Animate attack
                animateAction('ai', activeAIIndex, 'player', targetPlayerIndex, 'attack');
                
            } else if (selectedAction === 'defend') {
                // Defensive action
                activeAI.defending = true;
                
                // Log action
                addToBattleLog(`*${activeAI.name}* takes a defensive stance, reducing incoming damage!`);
                
                // Chance to apply protected status
                if (Math.random() < 0.3) {
                    addStatusEffect(activeAI, 'protected', 2);
                    addToBattleLog(`${activeAI.name} gains **Protected** status!`);
                }
                
                // Charge ultimate
                if (!activeAI.isUltimateReady) {
                    const chargeAmount = 0.1;
                    activeAI.ultimateCharge = Math.min(1, activeAI.ultimateCharge + chargeAmount);
                    
                    if (activeAI.ultimateCharge >= 1) {
                        activeAI.isUltimateReady = true;
                        addToBattleLog(`*${activeAI.name}'s* ultimate ability is now ready!`);
                    }
                }
                
                activeAI.actionsPerformed++;
                
                // Animate defend
                animateAction('ai', activeAIIndex, null, null, 'defend');
                
            } else if (selectedAction === 'special') {
                if (activeAI.isUltimateReady) {
                    // Use ultimate ability
                    let ultimateDamage = Math.floor(activeAI.bp * 0.25) + Math.floor(Math.random() * 10);
                    
                    // Play ultimate sound
                    playSound('ultimate');
                    
                    // Apply defensive reductions
                    if (targetPlayer.defending) {
                        ultimateDamage = Math.floor(ultimateDamage * 0.8);
                    }
                    
                    // Apply ultimate
                    targetPlayer.currentBp = Math.max(0, targetPlayer.currentBp - ultimateDamage);
                    
                    // Update stats
                    activeAI.damageDealt += ultimateDamage;
                    gameState.battleStats.damageDealt.ai += ultimateDamage;
                    gameState.battleStats.ultimatesUsed.ai++;
                    activeAI.actionsPerformed++;
                    
                    // Log action
                    addToBattleLog(`*${activeAI.name}* unleashes their ultimate ability **${activeAI.ultimate}** on ${targetPlayer.name} for **${ultimateDamage} damage**!`);
                    
                    // Apply character-specific ultimate effects
                    if (activeAI.ultimateEffect && activeAI.ultimateEffect.includes('all')) {
                        // Area effect ultimates
                        gameState.playerTeam.forEach(player => {
                            if (player.currentBp > 0 && player.id !== targetPlayer.id) {
                                const splashDamage = Math.floor(ultimateDamage * 0.4);
                                player.currentBp = Math.max(0, player.currentBp - splashDamage);
                                activeAI.damageDealt += splashDamage;
                                gameState.battleStats.damageDealt.ai += splashDamage;
                            }
                        });
                        addToBattleLog(`The ultimate ability affects all enemies!`);
                    }
                    
                    // Reset ultimate
                    activeAI.isUltimateReady = false;
                    activeAI.ultimateCharge = 0;
                    
                    // Animate ultimate
                    animateAction('ai', activeAIIndex, 'player', targetPlayerIndex, 'ultimate');
                    
                } else {
                    // Charge ultimate
                    activeAI.ultimateCharge = 1;
                    activeAI.isUltimateReady = true;
                    
                    // Log action
                    addToBattleLog(`*${activeAI.name}* focuses energy, preparing their ultimate ability!`);
                    
                    activeAI.actionsPerformed++;
                    
                    // Animate special
                    animateAction('ai', activeAIIndex, null, null, 'hold-ground');
                }
                
            } else if (selectedAction === 'skill') {
                // Find available skills (not on cooldown)
                const availableSkills = activeAI.skills.filter((_, index) => 
                    !activeAI.cooldowns[index] || activeAI.cooldowns[index] <= 0
                );
                
                if (availableSkills.length > 0) {
                    // Select skill based on situation
                    let selectedSkill;
                    let selectedSkillIndex;
                    
                    if (activeAI.currentBp < activeAI.bp * 0.4) {
                        // Low health, prioritize defensive or healing skills
                        const defensiveSkills = availableSkills.filter(skill => 
                            skill.type === 'defensive' || skill.type === 'healing' || skill.type === 'lifesteal'
                        );
                        
                        if (defensiveSkills.length > 0) {
                            selectedSkill = defensiveSkills[Math.floor(Math.random() * defensiveSkills.length)];
                        } else {
                            selectedSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                        }
                    } else if (targetPlayer.currentBp < targetPlayer.bp * 0.3) {
                        // Target is weak, prioritize offensive skills
                        const offensiveSkills = availableSkills.filter(skill => 
                            skill.type === 'offensive' || skill.type === 'control'
                        );
                        
                        if (offensiveSkills.length > 0) {
                            selectedSkill = offensiveSkills[Math.floor(Math.random() * offensiveSkills.length)];
                        } else {
                            selectedSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                        }
                    } else {
                        // Default case, random selection
                        selectedSkill = availableSkills[Math.floor(Math.random() * availableSkills.length)];
                    }
                    
                    // Find the index of this skill in the original skills array
                    selectedSkillIndex = activeAI.skills.findIndex(skill => skill.name === selectedSkill.name);
                    
                    // Set cooldown
                    activeAI.cooldowns[selectedSkillIndex] = selectedSkill.cooldown;
                    
                    // Play sound
                    playSound('attack');
                    
                    // Process skill based on type
                    if (selectedSkill.type === 'offensive' || selectedSkill.type === 'control') {
                        // Extract damage from skill description
                        const damageMatch = selectedSkill.description.match(/dealing (\d+) damage/);
                        let skillDamage = damageMatch ? parseInt(damageMatch[1]) : 0;
                        
                        // Apply defensive reductions
                        if (targetPlayer.defending) {
                            skillDamage = Math.floor(skillDamage * 0.7);
                        }
                        
                        // Apply damage
                        if (skillDamage > 0) {
                            targetPlayer.currentBp = Math.max(0, targetPlayer.currentBp - skillDamage);
                            activeAI.damageDealt += skillDamage;
                            gameState.battleStats.damageDealt.ai += skillDamage;
                        }
                        
                        // Check for status effects
                        let appliedStatus = null;
                        const statusMatch = selectedSkill.description.match(/(\d+)% (\w+) chance/);
                        if (statusMatch) {
                            const chance = parseInt(statusMatch[1]) / 100;
                            const statusType = statusMatch[2];
                            
                            // Map common status terms
                            const statusMap = {
                                'stun': 'stunned',
                                'burn': 'burned',
                                'poison': 'poisoned',
                                'freeze': 'frozen'
                            };
                            
                            if (Math.random() < chance) {
                                appliedStatus = statusMap[statusType] || statusType;
                                addStatusEffect(targetPlayer, appliedStatus, appliedStatus === 'stunned' ? 1 : 2);
                                gameState.battleStats.statusEffectsApplied.ai++;
                            }
                        }
                        
                        // Log action
                        addToBattleLog(`*${activeAI.name}* uses **${selectedSkill.name}** on ${targetPlayer.name}${skillDamage > 0 ? ` for **${skillDamage} damage**` : ''}${appliedStatus ? ` and applies **${statusEffects[appliedStatus].name}**` : ''}!`);
                        
                        // Animate skill
                        animateAction('ai', activeAIIndex, 'player', targetPlayerIndex, selectedSkill.type === 'control' ? 'coordinate' : 'attack');
                        
                    } else if (selectedSkill.type === 'defensive' || selectedSkill.type === 'buff') {
                        // Apply to self
                        if (selectedSkill.description.includes('reducing damage')) {
                            activeAI.defending = true;
                            addStatusEffect(activeAI, 'protected', 2);
                        } else if (selectedSkill.description.includes('increasing damage')) {
                            addStatusEffect(activeAI, 'strengthened', 2);
                        }
                        
                        // Log action
                        addToBattleLog(`*${activeAI.name}* uses **${selectedSkill.name}**, ${selectedSkill.description.toLowerCase().replace(/dealing|for/g, '')}!`);
                        
                        // Animate defensive skill
                        animateAction('ai', activeAIIndex, null, null, 'hold-ground');
                        
                    } else if (selectedSkill.type === 'lifesteal') {
                        // Extract damage from skill description
                        const damageMatch = selectedSkill.description.match(/(\d+) damage/);
                        if (damageMatch) {
                            let skillDamage = parseInt(damageMatch[1]);
                            
                            // Apply defensive reductions
                            if (targetPlayer.defending) {
                                skillDamage = Math.floor(skillDamage * 0.7);
                            }
                            
                            // Apply damage
                            targetPlayer.currentBp = Math.max(0, targetPlayer.currentBp - skillDamage);
                            activeAI.damageDealt += skillDamage;
                            gameState.battleStats.damageDealt.ai += skillDamage;
                            
                            // Calculate healing (from description or default to 50%)
                            const healPercentMatch = selectedSkill.description.match(/heal for (\d+)% of damage/);
                            const healPercent = healPercentMatch ? parseInt(healPercentMatch[1]) / 100 : 0.5;
                            
                            const healAmount = Math.floor(skillDamage * healPercent);
                            activeAI.currentBp = Math.min(activeAI.bp, activeAI.currentBp + healAmount);
                            activeAI.healingDone += healAmount;
                            gameState.battleStats.healingDone.ai += healAmount;
                            
                            // Log action
                            addToBattleLog(`*${activeAI.name}* uses **${selectedSkill.name}** on ${targetPlayer.name} for **${skillDamage} damage** and heals for **${healAmount} BP**!`);
                        }
                        
                        // Animate lifesteal
                        animateAction('ai', activeAIIndex, 'player', targetPlayerIndex, 'ground');
                    }
                    
                    gameState.battleStats.skillsUsed.ai++;
                    activeAI.actionsPerformed++;
                } else {
                    // No skills available, fall back to attack
                    const baseDamage = Math.floor(activeAI.bp * 0.1) + Math.floor(Math.random() * 5);
                    const damage = Math.floor(baseDamage * aiStrategy.effects.damageMultiplier);
                    
                    // Play sound
                    playSound('attack');
                    
                    // Apply defensive reductions
                    const finalDamage = targetPlayer.defending ? Math.floor(damage * 0.6) : damage;
                    targetPlayer.currentBp = Math.max(0, targetPlayer.currentBp - finalDamage);
                    
                    // Update stats
                    activeAI.damageDealt += finalDamage;
                    gameState.battleStats.damageDealt.ai += finalDamage;
                    activeAI.actionsPerformed++;
                    
                    // Log action
                    addToBattleLog(`*${activeAI.name}* attacks ${targetPlayer.name} for **${finalDamage} damage**!`);
                    
                    // Animate attack
                    animateAction('ai', activeAIIndex, 'player', targetPlayerIndex, 'attack');
                }
            }
            
            // Process end of turn status effects
            decrementStatusEffects(activeAI);
        }

        function animateAction(attackerTeam, attackerIndex, targetTeam, targetIndex, animationType) {
            const attackerCard = document.querySelector(`.battle-character-card[data-team="${attackerTeam}"][data-character-index="${attackerIndex}"]`);
            const targetCard = targetTeam && targetIndex !== null 
                             ? document.querySelector(`.battle-character-card[data-team="${targetTeam}"][data-character-index="${targetIndex}"]`)
                             : null;
            
            if (attackerCard) {
                // Add animation class based on type
                attackerCard.classList.add(animationType);
                
                setTimeout(() => {
                    // If we have a target, animate it too
                    if (targetCard && (animationType === 'attack' || animationType === 'ground' || 
                                      animationType === 'aerial' || animationType === 'coordinate' || 
                                      animationType === 'ultimate')) {
                        targetCard.classList.add('damage');
                        setTimeout(() => {
                            targetCard.classList.remove('damage');
                        }, 500);
                    }
                    
                    // Remove attacker animation
                    attackerCard.classList.remove(animationType);
                }, animationType === 'ultimate' ? 500 : 300);
            }
        }

        function addToBattleLog(message) {
            const battleLog = document.getElementById('battle-log');
            gameState.battleLog.push(message);
            
            // Convert markdown to HTML
            battleLog.innerHTML = marked.parse(gameState.battleLog.join('\n\n'));
            
            // Scroll to bottom
            battleLog.scrollTop = battleLog.scrollHeight;
        }

        function showErrorMessage(message) {
            const errorLog = document.getElementById('error-log');
            gameState.errorLog.push(`[ERROR] ${message}`);
            
            errorLog.innerHTML = '';
            gameState.errorLog.forEach(error => {
                const errorElement = document.createElement('p');
                errorElement.className = 'text-red-500';
                errorElement.textContent = error;
                errorLog.appendChild(errorElement);
            });
            
            // Show error log
            errorLog.classList.remove('hidden');
            
            // Scroll to bottom
            errorLog.scrollTop = errorLog.scrollHeight;
        }

        function toggleErrorLog() {
            const errorLog = document.getElementById('error-log');
            if (errorLog.classList.contains('hidden')) {
                errorLog.classList.remove('hidden');
            } else {
                errorLog.classList.add('hidden');
            }
        }

        function endBattle(winner) {
            gameState.winner = winner;
            
            // Play victory/defeat sound
            playSound(winner === 'player' ? 'victory' : 'defeat');
            
            // Log battle end
            addToBattleLog(`## Battle Ended! ${winner === 'player' ? 'You win!' : 'AI wins!'}`);
            
            // Determine MVP
            calculateMVP();
            
            // Show battle summary
            addToBattleLog(`\n### Battle Summary:`);
            addToBattleLog(`- Rounds played: ${gameState.battleStats.roundsPlayed}`);
            addToBattleLog(`- Player damage: ${gameState.battleStats.damageDealt.player}`);
            addToBattleLog(`- AI damage: ${gameState.battleStats.damageDealt.ai}`);
            addToBattleLog(`- MVP: ${gameState.mvp.name}`);
            
            // Enable the "next turn" button which will navigate to results
            document.getElementById('next-turn').textContent = 'View Results';
            document.getElementById('next-turn').addEventListener('click', showResultsScreen, { once: true });
        }

        function calculateMVP() {
            // Combine all characters
            const allCharacters = [...gameState.playerTeam, ...gameState.aiTeam];
            
            // Calculate score for each character
            const characterScores = allCharacters.map(character => {
                const team = gameState.playerTeam.includes(character) ? 'player' : 'ai';
                const initialBp = character.bp;
                const survivedBattle = character.currentBp > 0;
                const damageScore = character.damageDealt * 1.5;
                const healingScore = character.healingDone * 2;
                const survivalBonus = survivedBattle ? initialBp * 0.5 : 0;
                const actionBonus = character.actionsPerformed * 5;
                
                const totalScore = damageScore + healingScore + survivalBonus + actionBonus;
                
                return {
                    character,
                    score: totalScore,
                    team,
                    scoreBreakdown: {
                        damage: damageScore,
                        healing: healingScore,
                        survival: survivalBonus,
                        actions: actionBonus
                    }
                };
            });
            
            // Find the character with the highest score
            characterScores.sort((a, b) => b.score - a.score);
            gameState.mvp = characterScores[0].character;
            gameState.mvpScore = characterScores[0].score;
            gameState.mvpBreakdown = characterScores[0].scoreBreakdown;
        }

        function showResultsScreen() {
            // Prepare results screen
            setupResultsScreen();
            
            // Switch to results screen
            changeScreen('results');
        }

        function setupResultsScreen() {
            // Update winner announcement
            document.getElementById('winner-announcement').textContent = gameState.winner === 'player' ? 'You won the battle!' : 'AI won the battle!';
            document.getElementById('winner-announcement').className = gameState.winner === 'player' ? 'text-base md:text-lg font-medium golden-neon-text' : 'text-base md:text-lg font-medium text-red-500';
            
            // Update battle stats
            const statsContainer = document.getElementById('battle-stats');
            statsContainer.innerHTML = `
                <p><span class="font-medium">Rounds Played:</span> ${gameState.battleStats.roundsPlayed}</p>
                <p><span class="font-medium">Your Team Damage:</span> ${gameState.battleStats.damageDealt.player}</p>
                <p><span class="font-medium">Opponent Team Damage:</span> ${gameState.battleStats.damageDealt.ai}</p>
                <p><span class="font-medium">Your Healing Done:</span> ${gameState.battleStats.healingDone.player}</p>
                <p><span class="font-medium">Critical Hits (Your Team):</span> ${gameState.battleStats.criticalHits.player}</p>
                <p><span class="font-medium">Critical Hits (Opponent):</span> ${gameState.battleStats.criticalHits.ai}</p>
                <p><span class="font-medium">Ultimate Abilities Used (Your Team):</span> ${gameState.battleStats.ultimatesUsed.player}</p>
                <p><span class="font-medium">Ultimate Abilities Used (Opponent):</span> ${gameState.battleStats.ultimatesUsed.ai}</p>
                <p><span class="font-medium">Skills Used (Your Team):</span> ${gameState.battleStats.skillsUsed.player}</p>
                <p><span class="font-medium">Status Effects Applied (Your Team):</span> ${gameState.battleStats.statusEffectsApplied.player}</p>
            `;
            
            // Update MVP character
            const mvpContainer = document.getElementById('mvp-character');
            mvpContainer.innerHTML = `
                <div class="mb-2 md:mb-3">
                    <h4 class="text-lg font-semibold golden-neon-text">${gameState.mvp.name}</h4>
                    <div class="text-xs md:text-sm">${gameState.mvp.universe.charAt(0).toUpperCase() + gameState.mvp.universe.slice(1)} Universe</div>
                </div>
                <div class="text-xs md:text-sm">
                    <p><span class="font-medium">Battle Power:</span> ${gameState.mvp.bp}</p>
                    <p><span class="font-medium">Damage Dealt:</span> ${gameState.mvp.damageDealt}</p>
                    <p><span class="font-medium">Healing Done:</span> ${gameState.mvp.healingDone || 0}</p>
                    <p><span class="font-medium">Ultimate Ability:</span> ${gameState.mvp.ultimate}</p>
                    <p class="mt-2">${gameState.mvp.description}</p>
                </div>
            `;
            
            // Update battle summary
            const summaryContainer = document.getElementById('battle-summary');
            
            // Get key moments from battle log
            const keyMoments = gameState.battleLog.filter(entry => 
                entry.includes('Critical Hit') || 
                entry.includes('ultimate ability') ||
                entry.includes('## Round') ||
                entry.includes('## Battle')
            ).slice(0, 5);
            
            summaryContainer.innerHTML = `
                <p class="mb-2">Highlight moments from the battle:</p>
                <ul class="list-disc pl-5 space-y-1">
                    ${keyMoments.map(moment => `<li>${moment.replace(/\*/g, '').replace(/\*\*/g, '')}</li>`).join('')}
                </ul>
                
                <div class="mt-3 md:mt-4">
                    <p class="font-medium golden-neon-text">Team Composition:</p>
                    <p>Your Team (${teamStrategies[gameState.teamStrategy].name}): ${gameState.playerTeam.map(c => c.name).join(', ')}</p>
                    <p>AI Team (${teamStrategies[gameState.aiTeamStrategy].name}): ${gameState.aiTeam.map(c => c.name).join(', ')}</p>
                </div>
                
                <div class="mt-3 md:mt-4">
                    <p class="font-medium golden-neon-text">Battle Style: ${battleStyles[gameState.battleStyle].name}</p>
                    <p class="text-xs md:text-sm">${battleStyles[gameState.battleStyle].description}</p>
                </div>
            `;
            
            // Update detailed battle recap
            const recapContainer = document.getElementById('battle-recap');
            
            // Create a more detailed story of the battle
            const playerTeamNames = gameState.playerTeam.map(c => c.name).join(', ');
            const aiTeamNames = gameState.aiTeam.map(c => c.name).join(', ');
            const playerLeader = gameState.playerTeam.find(c => c.id === gameState.leaderId);
            const aiLeader = gameState.aiTeam.find(c => c.id === gameState.aiLeaderId);
            
            let recap = `<p class="font-medium golden-neon-text">Battle Recap</p>`;
            recap += `<p>In this epic clash, a team consisting of ${playerTeamNames} faced off against ${aiTeamNames}.</p>`;
            
            if (playerLeader) {
                recap += `<p>Your team was led by ${playerLeader.name}, providing ${playerLeader.leaderBonus}.</p>`;
            }
            
            if (aiLeader) {
                recap += `<p>The opponent team was led by ${aiLeader.name}, giving them an edge with ${aiLeader.leaderBonus}.</p>`;
            }
            
            recap += `<p>Your team adopted a ${teamStrategies[gameState.teamStrategy].name} strategy, while the opponents went with a ${teamStrategies[gameState.aiTeamStrategy].name} approach.</p>`;
            
            // Add synergy information
            const activePlayerSynergies = gameState.activeSynergies.filter(s => s.active);
            if (activePlayerSynergies.length > 0) {
                recap += `<p>Your team synergies (${activePlayerSynergies.map(s => s.name).join(', ')}) provided powerful bonuses throughout the battle.</p>`;
            }
            
            // Add battle progression
            recap += `<p>The battle lasted ${gameState.battleStats.roundsPlayed} rounds, with both sides fighting fiercely.</p>`;
            
            // Add damage metrics
            const playerTotalBP = gameState.playerTeam.reduce((sum, c) => sum + c.bp, 0);
            const aiTotalBP = gameState.aiTeam.reduce((sum, c) => sum + c.bp, 0);
            const playerDamageEfficiency = (gameState.battleStats.damageDealt.player / playerTotalBP).toFixed(2);
            const aiDamageEfficiency = (gameState.battleStats.damageDealt.ai / aiTotalBP).toFixed(2);
            
            recap += `<p>Your team dealt ${gameState.battleStats.damageDealt.player} total damage (${playerDamageEfficiency}x efficiency), while the opponent team dealt ${gameState.battleStats.damageDealt.ai} total damage (${aiDamageEfficiency}x efficiency).</p>`;
            
            // Add ultimate usage
            recap += `<p>Your team unleashed ${gameState.battleStats.ultimatesUsed.player} ultimate abilities, compared to the opponent's ${gameState.battleStats.ultimatesUsed.ai}.</p>`;
            
            // Add MVP information
            recap += `<p>The battle's MVP was ${gameState.mvp.name}, who contributed exceptionally with ${gameState.mvp.damageDealt} damage dealt and ${gameState.mvp.healingDone || 0} healing done.</p>`;
            
            // Add battle outcome
            if (gameState.winner === 'player') {
                recap += `<p class="font-medium golden-neon-text">Your team emerged victorious, defeating all opponent characters!</p>`;
            } else {
                recap += `<p>Despite your efforts, the opponent team prevailed this time.</p>`;
            }
            
            // Add battle style effectiveness
            recap += `<p>Your chosen battle style (${battleStyles[gameState.battleStyle].name}) proved to be ${gameState.winner === 'player' ? 'effective' : 'challenging'} against the opponent's strategy.</p>`;
            
            // Add recommendations for future battles
            recap += `<p class="font-medium mt-3 md:mt-4 golden-neon-text">Strategic Analysis:</p>`;
            
            if (gameState.battleStats.damageDealt.player < gameState.battleStats.damageDealt.ai) {
                recap += `<p>Consider focusing more on offensive capabilities in future battles.</p>`;
            }
            
            if (gameState.battleStats.healingDone.player < 20) {
                recap += `<p>Your team lacked healing abilities. Consider including characters with support skills.</p>`;
            }
            
            if (gameState.battleStats.ultimatesUsed.player < gameState.battleStats.ultimatesUsed.ai) {
                recap += `<p>Try to charge and use ultimate abilities more frequently for maximum impact.</p>`;
            }
            
            if (gameState.battleStats.statusEffectsApplied.player < 3) {
                recap += `<p>Using status effects can give you a strategic advantage. Look for characters with control abilities.</p>`;
            }
            
            recapContainer.innerHTML = recap;
        }

        function saveBattleToHistory() {
            // Create battle record
            const battleRecord = {
                id: Date.now(),
                date: new Date().toLocaleDateString(),
                playerTeam: gameState.playerTeam.map(c => ({
                    id: c.id,
                    name: c.name,
                    finalBp: c.currentBp,
                    damageDealt: c.damageDealt,
                    healingDone: c.healingDone || 0
                })),
                aiTeam: gameState.aiTeam.map(c => ({
                    id: c.id,
                    name: c.name,
                    finalBp: c.currentBp,
                    damageDealt: c.damageDealt,
                    healingDone: c.healingDone || 0
                })),
                winner: gameState.winner,
                mvp: {
                    id: gameState.mvp.id,
                    name: gameState.mvp.name
                },
                stats: gameState.battleStats,
                rounds: gameState.battleStats.roundsPlayed,
                battleStyle: gameState.battleStyle,
                teamStrategy: gameState.teamStrategy,
                leaderId: gameState.leaderId
            };
            
            // Add to battle history
            gameState.battleHistory.push(battleRecord);
            
            // Save to "localStorage" (although not actually accessible in the iframe)
            try {
                // This won't work in the iframe but is good practice
                localStorage.setItem('epicAIBattleHistory', JSON.stringify(gameState.battleHistory));
            } catch (error) {
                showErrorMessage('Battle saved to memory but cannot be stored permanently in this environment');
            }
            
            // Update battle history display
            updateBattleHistoryDisplay();
            
            // Show confirmation
            alert('Battle saved to history! Access it from the main menu.');
            
            // Play sound
            playSound('attack');
        }

        function loadBattleHistory() {
            try {
                const savedHistory = localStorage.getItem('epicAIBattleHistory');
                if (savedHistory) {
                    gameState.battleHistory = JSON.parse(savedHistory);
                }
            } catch (error) {
                // Silent fail - localStorage not available in iframe
                gameState.battleHistory = [];
            }
            
            // Update battle history display
            updateBattleHistoryDisplay();
        }

        function updateBattleHistoryDisplay() {
            const recordsContainer = document.getElementById('battle-records');
            const noHistoryMessage = document.getElementById('no-history-message');
            
            // Clear container
            recordsContainer.innerHTML = '';
            
            if (gameState.battleHistory.length === 0) {
                recordsContainer.appendChild(noHistoryMessage);
                return;
            }
            
            noHistoryMessage.remove();
            
            // Add each battle record
            gameState.battleHistory.forEach(record => {
                const recordDiv = document.createElement('div');
                recordDiv.className = 'p-3 bg-light-card dark:bg-dark-card rounded-lg border border-light-border dark:border-dark-border mb-3 card-3d';
                
                recordDiv.innerHTML = `
                    <div class="card-3d-content">
                        <div class="flex justify-between items-start mb-2">
                            <div>
                                <h3 class="font-medium">Battle on ${record.date}</h3>
                                <p class="text-xs opacity-75">Result: ${record.winner === 'player' ? 'Victory' : 'Defeat'} (${record.rounds} rounds)</p>
                            </div>
                            <span class="px-2 py-1 text-xs rounded-full ${record.winner === 'player' ? 'bg-green-500' : 'bg-red-500'} text-white">
                                ${record.winner === 'player' ? 'Won' : 'Lost'}
                            </span>
                        </div>
                        <div class="text-xs grid grid-cols-2 gap-2">
                            <div>
                                <p class="font-medium golden-neon-text">Your Team:</p>
                                <ul class="list-disc pl-4">
                                    ${record.playerTeam.map(c => `<li>${c.name} (${c.damageDealt} dmg)</li>`).join('')}
                                </ul>
                            </div>
                            <div>
                                <p class="font-medium golden-neon-text">Opponent Team:</p>
                                <ul class="list-disc pl-4">
                                    ${record.aiTeam.map(c => `<li>${c.name} (${c.damageDealt} dmg)</li>`).join('')}
                                </ul>
                            </div>
                        </div>
                        <div class="mt-2 text-xs">
                            <p>MVP: <span class="golden-neon-text">${record.mvp.name}</span></p>
                            <p>Strategy: ${teamStrategies[record.teamStrategy].name} | Style: ${battleStyles[record.battleStyle].name}</p>
                        </div>
                    </div>
                `;
                
                recordsContainer.appendChild(recordDiv);
            });
        }

        function returnToTeamSelection() {
            // Reset game state
            gameState.playerTeam = [];
            gameState.aiTeam = [];
            gameState.activeSynergies = [];
            gameState.leaderId = null;
            gameState.teamStrategy = 'balanced';
            gameState.battleStyle = 'aerial-assault';
            
            // Play sound
            playSound('attack');
            
            // Reset UI
            updateTeamDisplay();
            updateCharacterCardStyles();
            updateSynergyInfo();
            
            // Reset strategy options
            document.querySelectorAll('.strategy-option').forEach(option => {
                option.classList.remove('border-primary', 'golden-glow');
                option.classList.add('border-light-border', 'dark:border-dark-border');
            });
            document.querySelector('.strategy-option[data-strategy="balanced"]').classList.add('border-primary', 'golden-glow');
            
            // Reset battle style options
            document.querySelectorAll('.battle-style-option').forEach(option => {
                option.classList.remove('border-primary', 'golden-glow');
                option.classList.add('border-light-border', 'dark:border-dark-border');
            });
            document.querySelector('.battle-style-option[data-style="aerial-assault"]').classList.add('border-primary', 'golden-glow');
            
            // Hide leader and strategy selection
            document.getElementById('leader-selection').classList.add('hidden');
            document.getElementById('strategy-selection').classList.add('hidden');
            document.getElementById('battle-style-selection').classList.add('hidden');
            
            // Reset next turn button
            document.getElementById('next-turn').textContent = 'Next Turn';
            
            document.getElementById('start-battle').disabled = true;
            
            // Switch to team selection screen
            changeScreen('teamSelection');
        }

        function changeScreen(screenName) {
            // Hide all screens
            Object.values(screens).forEach(screen => {
                screen.classList.add('hidden');
            });
            
            // Show selected screen
            screens[screenName].classList.remove('hidden');
            
            // Update game state
            gameState.screen = screenName;
            
            // Play sound
            playSound('attack');
            
            // Add golden particles when changing screens
            for (let i = 0; i < 10; i++) {
                createParticle(document.getElementById('particles-container'));
            }
        }
        
        // Chatbot functionality
        function initializeChatbot() {
            const chatbotContainer = document.getElementById('chatbot');
            const chatbotHeader = document.getElementById('chatbot-header');
            const messagesContainer = document.getElementById('chatbot-messages');
            const input = document.getElementById('chatbot-input');
            const sendButton = document.getElementById('send-message');
            const minimizeButton = document.getElementById('minimize-chatbot');
            const minimizeIcon = document.getElementById('minimize-icon');
            
            // Toggle chatbot visibility
            function toggleChatbot() {
                chatbotContainer.classList.toggle('minimized');
                minimizeIcon.textContent = chatbotContainer.classList.contains('minimized') ? '+' : '−';
                playSound('attack');
            }
            
            // Add event listener to minimize button
            minimizeButton.addEventListener('click', (e) => {
                e.stopPropagation();
                toggleChatbot();
            });
            
            // Add event listener to header (only toggles if minimized)
            chatbotHeader.addEventListener('click', () => {
                if (chatbotContainer.classList.contains('minimized')) {
                    toggleChatbot();
                }
            });
            
            // Handle sending messages
            async function sendChatbotMessage() {
                const message = input.value.trim();
                if (!message) return;
                
                // Clear input
                input.value = '';
                
                // Add user message to chat
                addChatMessage(message, 'user');
                
                // Play sound
                playSound('attack');
                
                // Show typing indicator
                const botTypingMessage = document.createElement('div');
                botTypingMessage.className = 'message bot-message';
                botTypingMessage.innerHTML = '<div class="animate-pulse">Thinking...</div>';
                messagesContainer.appendChild(botTypingMessage);
                
                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
                
                try {
                    // Prepare the question to send to Claude
                    const fullQuestion = `About Epic AI Battle: ${message}\n\nAnswer as if you're the game's assistant, providing information about game mechanics, characters, strategies, etc. Keep responses concise and helpful, under 150 words.`;
                    
                    if (window.Poe) {
                        // Register handler for bot response
                        const handlerId = `chat-handler-${Date.now()}`;
                        window.Poe.registerHandler(handlerId, (result) => {
                            if (result.responses.length > 0) {
                                const response = result.responses[0];
                                
                                if (result.status === "complete") {
                                    // Remove typing indicator and add response
                                    messagesContainer.removeChild(botTypingMessage);
                                    addChatMessage(response.content, 'bot');
                                }
                            }
                        });
                        
                        // Send message to Claude
                        await window.Poe.sendUserMessage("@Claude-3.7-Sonnet " + fullQuestion, {
                            handler: handlerId,
                            stream: false,
                            openChat: false
                        });
                    } else {
                        // Fallback for when Poe API is not available
                        setTimeout(() => {
                            messagesContainer.removeChild(botTypingMessage);
                            
                            // Generate a simple response based on question keywords
                            let response = "I'm your Epic AI Battle assistant. ";
                            
                            if (message.match(/character|hero|villain/i)) {
                                response += "The game features characters from Marvel, DC, and other universes, each with unique abilities, skills, and ultimates. Characters have different combat styles that synergize with battle strategies.";
                            } else if (message.match(/skill|ability|power/i)) {
                                response += "Characters have unique skills with different cooldowns and effects. Skills can be offensive, defensive, or support-based, and their effectiveness varies based on your battle style and team strategy.";
                            } else if (message.match(/synerg|team/i)) {
                                response += "Team synergies provide powerful bonuses when you select characters that work well together. Look for synergies like 'Mystic Arts', 'Cosmic Power', or 'Gods Among Us' for enhanced effectiveness.";
                            } else if (message.match(/battle style|combat/i)) {
                                response += "Battle styles like Aerial Assault, Ground Assault, and Coordinate Attacks provide different tactical advantages. Each character has different affinities for these styles based on their abilities.";
                            } else if (message.match(/strateg|tactic/i)) {
                                response += "Choose between Offensive, Defensive, and Balanced strategies. Offensive increases damage but reduces defense, Defensive does the opposite, and Balanced provides moderate bonuses to both.";
                            } else {
                                response += "You can ask about characters, skills, team synergies, battle styles, strategy, gameplay mechanics, or any other aspect of Epic AI Battle!";
                            }
                            
                            addChatMessage(response, 'bot');
                        }, 1000);
                    }
                } catch (error) {
                    // Remove typing indicator
                    messagesContainer.removeChild(botTypingMessage);
                    
                    // Add error message
                    addChatMessage("Sorry, I encountered an error processing your request. Please try again.", 'bot');
                }
            }
            
            // Add a message to the chat
            function addChatMessage(text, sender) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${sender}-message`;
                messageDiv.textContent = text;
                messagesContainer.appendChild(messageDiv);
                
                // Scroll to bottom
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
            
            // Setup event listeners
            sendButton.addEventListener('click', sendChatbotMessage);
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    sendChatbotMessage();
                }
            });
        }
</script>
</body>
</html>

Analyze and reiterate